// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file DescribeParameters.h
 * This header file contains the declaration of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifndef _FAST_DDS_GENERATED_RCL_INTERFACES_SRV_DESCRIBEPARAMETERS_H_
#define _FAST_DDS_GENERATED_RCL_INTERFACES_SRV_DESCRIBEPARAMETERS_H_

#include "rcl_interfaces/msg/ParameterDescriptor.h"



#include <stdint.h>
#include <array>
#include <string>
#include <vector>
#include <map>
#include <bitset>

#if defined(_WIN32)
#if defined(EPROSIMA_USER_DLL_EXPORT)
#define eProsima_user_DllExport __declspec( dllexport )
#else
#define eProsima_user_DllExport
#endif  // EPROSIMA_USER_DLL_EXPORT
#else
#define eProsima_user_DllExport
#endif  // _WIN32

#if defined(_WIN32)
#if defined(EPROSIMA_USER_DLL_EXPORT)
#if defined(DescribeParameters_SOURCE)
#define DescribeParameters_DllAPI __declspec( dllexport )
#else
#define DescribeParameters_DllAPI __declspec( dllimport )
#endif // DescribeParameters_SOURCE
#else
#define DescribeParameters_DllAPI
#endif  // EPROSIMA_USER_DLL_EXPORT
#else
#define DescribeParameters_DllAPI
#endif // _WIN32

namespace eprosima {
namespace fastcdr {
class Cdr;
} // namespace fastcdr
} // namespace eprosima


namespace rcl_interfaces {
    namespace srv {
        /*!
         * @brief This class represents the structure DescribeParameters_Request defined by the user in the IDL file.
         * @ingroup DESCRIBEPARAMETERS
         */
        class DescribeParameters_Request
        {
        public:
static constexpr std::string_view PACKAGE_RESOURCE_NAME = "rcl_interfaces/srv/DescribeParameters";
static constexpr std::string_view MCAP_SCHEMA = R"mcap_schema(================================================================================
IDL: rcl_interfaces/srv/DescribeParameters

// generated from rosidl_adapter/resource/srv.idl.em
// with input from rcl_interfaces/srv/DescribeParameters.srv
// generated code does not contain a copyright notice


module rcl_interfaces {
  module srv {
    @verbatim (language="comment", text=
      "A list of parameters of which to get the descriptor.")
    struct DescribeParameters_Request {
      sequence<string> names;
    };
    @verbatim (language="comment", text=
      "A list of the descriptors of all parameters requested in the same order" "\n"
      "as they were requested. This list has the same length as the list of" "\n"
      "parameters requested.")
    struct DescribeParameters_Response {
      sequence<rcl_interfaces::msg::ParameterDescriptor> descriptors;
    };
  };
};

================================================================================
IDL: rcl_interfaces/msg/ParameterDescriptor

// generated from rosidl_adapter/resource/msg.idl.em
// with input from rcl_interfaces/msg/ParameterDescriptor.msg
// generated code does not contain a copyright notice


module rcl_interfaces {
  module msg {
    @verbatim (language="comment", text=
      "This is the message to communicate a parameter's descriptor.")
    struct ParameterDescriptor {
      @verbatim (language="comment", text=
        "The name of the parameter.")
      string name;

      @verbatim (language="comment", text=
        "Enum values are defined in the `ParameterType.msg` message.")
      uint8 type;

      @verbatim (language="comment", text=
        "Description of the parameter, visible from introspection tools.")
      string description;

      @verbatim (language="comment", text=
        "Parameter constraints" "\n"
        "Plain English description of additional constraints which cannot be expressed" "\n"
        "with the available constraints, e.g. \"only prime numbers\"." "\n"
        "" "\n"
        "By convention, this should only be used to clarify constraints which cannot" "\n"
        "be completely expressed with the parameter constraints below.")
      string additional_constraints;

      @verbatim (language="comment", text=
        "If 'true' then the value cannot change after it has been initialized.")
      @default (value=FALSE)
      boolean read_only;

      @verbatim (language="comment", text=
        "If true, the parameter is allowed to change type.")
      @default (value=FALSE)
      boolean dynamic_typing;

      @verbatim (language="comment", text=
        "If any of the following sequences are not empty, then the constraint inside of" "\n"
        "them apply to this parameter." "\n"
        "" "\n"
        "FloatingPointRange and IntegerRange are mutually exclusive." "\n"
        "FloatingPointRange consists of a from_value, a to_value, and a step.")
      sequence<rcl_interfaces::msg::FloatingPointRange, 1> floating_point_range;

      @verbatim (language="comment", text=
        "IntegerRange consists of a from_value, a to_value, and a step.")
      sequence<rcl_interfaces::msg::IntegerRange, 1> integer_range;
    };
  };
};

================================================================================
IDL: rcl_interfaces/msg/FloatingPointRange

// generated from rosidl_adapter/resource/msg.idl.em
// with input from rcl_interfaces/msg/FloatingPointRange.msg
// generated code does not contain a copyright notice


module rcl_interfaces {
  module msg {
    @verbatim (language="comment", text=
      "Represents bounds and a step value for a floating point typed parameter.")
    struct FloatingPointRange {
      @verbatim (language="comment", text=
        "Start value for valid values, inclusive.")
      double from_value;

      @verbatim (language="comment", text=
        "End value for valid values, inclusive.")
      double to_value;

      @verbatim (language="comment", text=
        "Size of valid steps between the from and to bound." "\n"
        "" "\n"
        "Step is considered to be a magnitude, therefore negative values are treated" "\n"
        "the same as positive values, and a step value of zero implies a continuous" "\n"
        "range of values." "\n"
        "" "\n"
        "Ideally, the step would be less than or equal to the distance between the" "\n"
        "bounds, as well as an even multiple of the distance between the bounds, but" "\n"
        "neither are required." "\n"
        "" "\n"
        "If the absolute value of the step is larger than or equal to the distance" "\n"
        "between the two bounds, then the bounds will be the only valid values. e.g. if" "\n"
        "the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the" "\n"
        "valid values will be 1.0 and 2.0." "\n"
        "" "\n"
        "If the step is less than the distance between the bounds, but the distance is" "\n"
        "not a multiple of the step, then the \"to\" bound will always be a valid value," "\n"
        "e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}" "\n"
        "then the valid values will be 2.0, 4.0, and 5.0.")
      double step;
    };
  };
};

================================================================================
IDL: rcl_interfaces/msg/IntegerRange

// generated from rosidl_adapter/resource/msg.idl.em
// with input from rcl_interfaces/msg/IntegerRange.msg
// generated code does not contain a copyright notice


module rcl_interfaces {
  module msg {
    @verbatim (language="comment", text=
      "Represents bounds and a step value for an integer typed parameter.")
    struct IntegerRange {
      @verbatim (language="comment", text=
        "Start value for valid values, inclusive.")
      int64 from_value;

      @verbatim (language="comment", text=
        "End value for valid values, inclusive.")
      int64 to_value;

      @verbatim (language="comment", text=
        "Size of valid steps between the from and to bound." "\n"
        "" "\n"
        "A step value of zero implies a continuous range of values. Ideally, the step" "\n"
        "would be less than or equal to the distance between the bounds, as well as an" "\n"
        "even multiple of the distance between the bounds, but neither are required." "\n"
        "" "\n"
        "If the absolute value of the step is larger than or equal to the distance" "\n"
        "between the two bounds, then the bounds will be the only valid values. e.g. if" "\n"
        "the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid" "\n"
        "values will be 1 and 2." "\n"
        "" "\n"
        "If the step is less than the distance between the bounds, but the distance is" "\n"
        "not a multiple of the step, then the \"to\" bound will always be a valid value," "\n"
        "e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then" "\n"
        "the valid values will be 2, 4, and 5.")
      uint64 step;
    };
  };
};

)mcap_schema";
static constexpr std::string_view MCAP_MSG_SCHEMA = R"mcap_msg_schema(<unavailable>)mcap_msg_schema";

            /*!
             * @brief Default constructor.
             */
            eProsima_user_DllExport DescribeParameters_Request();

            /*!
             * @brief Default destructor.
             */
            eProsima_user_DllExport ~DescribeParameters_Request();

            /*!
             * @brief Copy constructor.
             * @param x Reference to the object rcl_interfaces::srv::DescribeParameters_Request that will be copied.
             */
            eProsima_user_DllExport DescribeParameters_Request(
                    const DescribeParameters_Request& x);

            /*!
             * @brief Move constructor.
             * @param x Reference to the object rcl_interfaces::srv::DescribeParameters_Request that will be copied.
             */
            eProsima_user_DllExport DescribeParameters_Request(
                    DescribeParameters_Request&& x) noexcept;

            /*!
             * @brief Copy assignment.
             * @param x Reference to the object rcl_interfaces::srv::DescribeParameters_Request that will be copied.
             */
            eProsima_user_DllExport DescribeParameters_Request& operator =(
                    const DescribeParameters_Request& x);

            /*!
             * @brief Move assignment.
             * @param x Reference to the object rcl_interfaces::srv::DescribeParameters_Request that will be copied.
             */
            eProsima_user_DllExport DescribeParameters_Request& operator =(
                    DescribeParameters_Request&& x) noexcept;

            /*!
             * @brief Comparison operator.
             * @param x rcl_interfaces::srv::DescribeParameters_Request object to compare.
             */
            eProsima_user_DllExport bool operator ==(
                    const DescribeParameters_Request& x) const;

            /*!
             * @brief Comparison operator.
             * @param x rcl_interfaces::srv::DescribeParameters_Request object to compare.
             */
            eProsima_user_DllExport bool operator !=(
                    const DescribeParameters_Request& x) const;

            /*!
             * @brief This function copies the value in member names
             * @param _names New value to be copied in member names
             */
            eProsima_user_DllExport void names(
                    const std::vector<std::string>& _names);

            /*!
             * @brief This function moves the value in member names
             * @param _names New value to be moved in member names
             */
            eProsima_user_DllExport void names(
                    std::vector<std::string>&& _names);

            /*!
             * @brief This function returns a constant reference to member names
             * @return Constant reference to member names
             */
            eProsima_user_DllExport const std::vector<std::string>& names() const;

            /*!
             * @brief This function returns a reference to member names
             * @return Reference to member names
             */
            eProsima_user_DllExport std::vector<std::string>& names();

            /*!
            * @brief This function returns the maximum serialized size of an object
            * depending on the buffer alignment.
            * @param current_alignment Buffer alignment.
            * @return Maximum serialized size.
            */
            eProsima_user_DllExport static size_t getMaxCdrSerializedSize(
                    size_t current_alignment = 0);

            /*!
             * @brief This function returns the serialized size of a data depending on the buffer alignment.
             * @param data Data which is calculated its serialized size.
             * @param current_alignment Buffer alignment.
             * @return Serialized size.
             */
            eProsima_user_DllExport static size_t getCdrSerializedSize(
                    const rcl_interfaces::srv::DescribeParameters_Request& data,
                    size_t current_alignment = 0);


            /*!
             * @brief This function serializes an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void serialize(
                    eprosima::fastcdr::Cdr& cdr) const;

            /*!
             * @brief This function deserializes an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void deserialize(
                    eprosima::fastcdr::Cdr& cdr);



            /*!
             * @brief This function returns the maximum serialized size of the Key of an object
             * depending on the buffer alignment.
             * @param current_alignment Buffer alignment.
             * @return Maximum serialized size.
             */
            eProsima_user_DllExport static size_t getKeyMaxCdrSerializedSize(
                    size_t current_alignment = 0);

            /*!
             * @brief This function tells you if the Key has been defined for this type
             */
            eProsima_user_DllExport static bool isKeyDefined();

            /*!
             * @brief This function serializes the key members of an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void serializeKey(
                    eprosima::fastcdr::Cdr& cdr) const;

        private:

            std::vector<std::string> m_names;

        };
        /*!
         * @brief This class represents the structure DescribeParameters_Response defined by the user in the IDL file.
         * @ingroup DESCRIBEPARAMETERS
         */
        class DescribeParameters_Response
        {
        public:
static constexpr std::string_view PACKAGE_RESOURCE_NAME = "rcl_interfaces/srv/DescribeParameters";
static constexpr std::string_view MCAP_SCHEMA = R"mcap_schema(================================================================================
IDL: rcl_interfaces/srv/DescribeParameters

// generated from rosidl_adapter/resource/srv.idl.em
// with input from rcl_interfaces/srv/DescribeParameters.srv
// generated code does not contain a copyright notice


module rcl_interfaces {
  module srv {
    @verbatim (language="comment", text=
      "A list of parameters of which to get the descriptor.")
    struct DescribeParameters_Request {
      sequence<string> names;
    };
    @verbatim (language="comment", text=
      "A list of the descriptors of all parameters requested in the same order" "\n"
      "as they were requested. This list has the same length as the list of" "\n"
      "parameters requested.")
    struct DescribeParameters_Response {
      sequence<rcl_interfaces::msg::ParameterDescriptor> descriptors;
    };
  };
};

================================================================================
IDL: rcl_interfaces/msg/ParameterDescriptor

// generated from rosidl_adapter/resource/msg.idl.em
// with input from rcl_interfaces/msg/ParameterDescriptor.msg
// generated code does not contain a copyright notice


module rcl_interfaces {
  module msg {
    @verbatim (language="comment", text=
      "This is the message to communicate a parameter's descriptor.")
    struct ParameterDescriptor {
      @verbatim (language="comment", text=
        "The name of the parameter.")
      string name;

      @verbatim (language="comment", text=
        "Enum values are defined in the `ParameterType.msg` message.")
      uint8 type;

      @verbatim (language="comment", text=
        "Description of the parameter, visible from introspection tools.")
      string description;

      @verbatim (language="comment", text=
        "Parameter constraints" "\n"
        "Plain English description of additional constraints which cannot be expressed" "\n"
        "with the available constraints, e.g. \"only prime numbers\"." "\n"
        "" "\n"
        "By convention, this should only be used to clarify constraints which cannot" "\n"
        "be completely expressed with the parameter constraints below.")
      string additional_constraints;

      @verbatim (language="comment", text=
        "If 'true' then the value cannot change after it has been initialized.")
      @default (value=FALSE)
      boolean read_only;

      @verbatim (language="comment", text=
        "If true, the parameter is allowed to change type.")
      @default (value=FALSE)
      boolean dynamic_typing;

      @verbatim (language="comment", text=
        "If any of the following sequences are not empty, then the constraint inside of" "\n"
        "them apply to this parameter." "\n"
        "" "\n"
        "FloatingPointRange and IntegerRange are mutually exclusive." "\n"
        "FloatingPointRange consists of a from_value, a to_value, and a step.")
      sequence<rcl_interfaces::msg::FloatingPointRange, 1> floating_point_range;

      @verbatim (language="comment", text=
        "IntegerRange consists of a from_value, a to_value, and a step.")
      sequence<rcl_interfaces::msg::IntegerRange, 1> integer_range;
    };
  };
};

================================================================================
IDL: rcl_interfaces/msg/FloatingPointRange

// generated from rosidl_adapter/resource/msg.idl.em
// with input from rcl_interfaces/msg/FloatingPointRange.msg
// generated code does not contain a copyright notice


module rcl_interfaces {
  module msg {
    @verbatim (language="comment", text=
      "Represents bounds and a step value for a floating point typed parameter.")
    struct FloatingPointRange {
      @verbatim (language="comment", text=
        "Start value for valid values, inclusive.")
      double from_value;

      @verbatim (language="comment", text=
        "End value for valid values, inclusive.")
      double to_value;

      @verbatim (language="comment", text=
        "Size of valid steps between the from and to bound." "\n"
        "" "\n"
        "Step is considered to be a magnitude, therefore negative values are treated" "\n"
        "the same as positive values, and a step value of zero implies a continuous" "\n"
        "range of values." "\n"
        "" "\n"
        "Ideally, the step would be less than or equal to the distance between the" "\n"
        "bounds, as well as an even multiple of the distance between the bounds, but" "\n"
        "neither are required." "\n"
        "" "\n"
        "If the absolute value of the step is larger than or equal to the distance" "\n"
        "between the two bounds, then the bounds will be the only valid values. e.g. if" "\n"
        "the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the" "\n"
        "valid values will be 1.0 and 2.0." "\n"
        "" "\n"
        "If the step is less than the distance between the bounds, but the distance is" "\n"
        "not a multiple of the step, then the \"to\" bound will always be a valid value," "\n"
        "e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}" "\n"
        "then the valid values will be 2.0, 4.0, and 5.0.")
      double step;
    };
  };
};

================================================================================
IDL: rcl_interfaces/msg/IntegerRange

// generated from rosidl_adapter/resource/msg.idl.em
// with input from rcl_interfaces/msg/IntegerRange.msg
// generated code does not contain a copyright notice


module rcl_interfaces {
  module msg {
    @verbatim (language="comment", text=
      "Represents bounds and a step value for an integer typed parameter.")
    struct IntegerRange {
      @verbatim (language="comment", text=
        "Start value for valid values, inclusive.")
      int64 from_value;

      @verbatim (language="comment", text=
        "End value for valid values, inclusive.")
      int64 to_value;

      @verbatim (language="comment", text=
        "Size of valid steps between the from and to bound." "\n"
        "" "\n"
        "A step value of zero implies a continuous range of values. Ideally, the step" "\n"
        "would be less than or equal to the distance between the bounds, as well as an" "\n"
        "even multiple of the distance between the bounds, but neither are required." "\n"
        "" "\n"
        "If the absolute value of the step is larger than or equal to the distance" "\n"
        "between the two bounds, then the bounds will be the only valid values. e.g. if" "\n"
        "the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid" "\n"
        "values will be 1 and 2." "\n"
        "" "\n"
        "If the step is less than the distance between the bounds, but the distance is" "\n"
        "not a multiple of the step, then the \"to\" bound will always be a valid value," "\n"
        "e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then" "\n"
        "the valid values will be 2, 4, and 5.")
      uint64 step;
    };
  };
};

)mcap_schema";
static constexpr std::string_view MCAP_MSG_SCHEMA = R"mcap_msg_schema(<unavailable>)mcap_msg_schema";

            /*!
             * @brief Default constructor.
             */
            eProsima_user_DllExport DescribeParameters_Response();

            /*!
             * @brief Default destructor.
             */
            eProsima_user_DllExport ~DescribeParameters_Response();

            /*!
             * @brief Copy constructor.
             * @param x Reference to the object rcl_interfaces::srv::DescribeParameters_Response that will be copied.
             */
            eProsima_user_DllExport DescribeParameters_Response(
                    const DescribeParameters_Response& x);

            /*!
             * @brief Move constructor.
             * @param x Reference to the object rcl_interfaces::srv::DescribeParameters_Response that will be copied.
             */
            eProsima_user_DllExport DescribeParameters_Response(
                    DescribeParameters_Response&& x) noexcept;

            /*!
             * @brief Copy assignment.
             * @param x Reference to the object rcl_interfaces::srv::DescribeParameters_Response that will be copied.
             */
            eProsima_user_DllExport DescribeParameters_Response& operator =(
                    const DescribeParameters_Response& x);

            /*!
             * @brief Move assignment.
             * @param x Reference to the object rcl_interfaces::srv::DescribeParameters_Response that will be copied.
             */
            eProsima_user_DllExport DescribeParameters_Response& operator =(
                    DescribeParameters_Response&& x) noexcept;

            /*!
             * @brief Comparison operator.
             * @param x rcl_interfaces::srv::DescribeParameters_Response object to compare.
             */
            eProsima_user_DllExport bool operator ==(
                    const DescribeParameters_Response& x) const;

            /*!
             * @brief Comparison operator.
             * @param x rcl_interfaces::srv::DescribeParameters_Response object to compare.
             */
            eProsima_user_DllExport bool operator !=(
                    const DescribeParameters_Response& x) const;

            /*!
             * @brief This function copies the value in member descriptors
             * @param _descriptors New value to be copied in member descriptors
             */
            eProsima_user_DllExport void descriptors(
                    const std::vector<rcl_interfaces::msg::ParameterDescriptor>& _descriptors);

            /*!
             * @brief This function moves the value in member descriptors
             * @param _descriptors New value to be moved in member descriptors
             */
            eProsima_user_DllExport void descriptors(
                    std::vector<rcl_interfaces::msg::ParameterDescriptor>&& _descriptors);

            /*!
             * @brief This function returns a constant reference to member descriptors
             * @return Constant reference to member descriptors
             */
            eProsima_user_DllExport const std::vector<rcl_interfaces::msg::ParameterDescriptor>& descriptors() const;

            /*!
             * @brief This function returns a reference to member descriptors
             * @return Reference to member descriptors
             */
            eProsima_user_DllExport std::vector<rcl_interfaces::msg::ParameterDescriptor>& descriptors();

            /*!
            * @brief This function returns the maximum serialized size of an object
            * depending on the buffer alignment.
            * @param current_alignment Buffer alignment.
            * @return Maximum serialized size.
            */
            eProsima_user_DllExport static size_t getMaxCdrSerializedSize(
                    size_t current_alignment = 0);

            /*!
             * @brief This function returns the serialized size of a data depending on the buffer alignment.
             * @param data Data which is calculated its serialized size.
             * @param current_alignment Buffer alignment.
             * @return Serialized size.
             */
            eProsima_user_DllExport static size_t getCdrSerializedSize(
                    const rcl_interfaces::srv::DescribeParameters_Response& data,
                    size_t current_alignment = 0);


            /*!
             * @brief This function serializes an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void serialize(
                    eprosima::fastcdr::Cdr& cdr) const;

            /*!
             * @brief This function deserializes an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void deserialize(
                    eprosima::fastcdr::Cdr& cdr);



            /*!
             * @brief This function returns the maximum serialized size of the Key of an object
             * depending on the buffer alignment.
             * @param current_alignment Buffer alignment.
             * @return Maximum serialized size.
             */
            eProsima_user_DllExport static size_t getKeyMaxCdrSerializedSize(
                    size_t current_alignment = 0);

            /*!
             * @brief This function tells you if the Key has been defined for this type
             */
            eProsima_user_DllExport static bool isKeyDefined();

            /*!
             * @brief This function serializes the key members of an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void serializeKey(
                    eprosima::fastcdr::Cdr& cdr) const;

        private:

            std::vector<rcl_interfaces::msg::ParameterDescriptor> m_descriptors;

        };
    } // namespace srv
} // namespace rcl_interfaces

#endif // _FAST_DDS_GENERATED_RCL_INTERFACES_SRV_DESCRIBEPARAMETERS_H_