// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file MultiDOFJointState.h
 * This header file contains the declaration of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifndef _FAST_DDS_GENERATED_SENSOR_MSGS_MSG_MULTIDOFJOINTSTATE_H_
#define _FAST_DDS_GENERATED_SENSOR_MSGS_MSG_MULTIDOFJOINTSTATE_H_

#include "geometry_msgs/msg/Twist.h"
#include "std_msgs/msg/Header.h"
#include "geometry_msgs/msg/Transform.h"
#include "geometry_msgs/msg/Wrench.h"

#include <fastrtps/utils/fixed_size_string.hpp>

#include <stdint.h>
#include <array>
#include <string>
#include <vector>
#include <map>
#include <bitset>

#if defined(_WIN32)
#if defined(EPROSIMA_USER_DLL_EXPORT)
#define eProsima_user_DllExport __declspec( dllexport )
#else
#define eProsima_user_DllExport
#endif  // EPROSIMA_USER_DLL_EXPORT
#else
#define eProsima_user_DllExport
#endif  // _WIN32

#if defined(_WIN32)
#if defined(EPROSIMA_USER_DLL_EXPORT)
#if defined(MultiDOFJointState_SOURCE)
#define MultiDOFJointState_DllAPI __declspec( dllexport )
#else
#define MultiDOFJointState_DllAPI __declspec( dllimport )
#endif // MultiDOFJointState_SOURCE
#else
#define MultiDOFJointState_DllAPI
#endif  // EPROSIMA_USER_DLL_EXPORT
#else
#define MultiDOFJointState_DllAPI
#endif // _WIN32

namespace eprosima {
namespace fastcdr {
class Cdr;
} // namespace fastcdr
} // namespace eprosima


namespace sensor_msgs {
    namespace msg {
        /*!
         * @brief This class represents the structure MultiDOFJointState defined by the user in the IDL file.
         * @ingroup MULTIDOFJOINTSTATE
         */
        class MultiDOFJointState
        {
        public:
static constexpr std::string_view PACKAGE_RESOURCE_NAME = "sensor_msgs/msg/MultiDOFJointState";
static constexpr std::string_view MCAP_SCHEMA = R"mcap_schema(================================================================================
IDL: sensor_msgs/msg/MultiDOFJointState

// generated from rosidl_adapter/resource/msg.idl.em
// with input from sensor_msgs/msg/MultiDOFJointState.msg
// generated code does not contain a copyright notice


module sensor_msgs {
  module msg {
    @verbatim (language="comment", text=
      "Representation of state for joints with multiple degrees of freedom," "\n"
      "following the structure of JointState which can only represent a single degree of freedom." "\n"
      "" "\n"
      "It is assumed that a joint in a system corresponds to a transform that gets applied" "\n"
      "along the kinematic chain. For example, a planar joint (as in URDF) is 3DOF (x, y, yaw)" "\n"
      "and those 3DOF can be expressed as a transformation matrix, and that transformation" "\n"
      "matrix can be converted back to (x, y, yaw)" "\n"
      "" "\n"
      "Each joint is uniquely identified by its name" "\n"
      "The header specifies the time at which the joint states were recorded. All the joint states" "\n"
      "in one message have to be recorded at the same time." "\n"
      "" "\n"
      "This message consists of a multiple arrays, one for each part of the joint state." "\n"
      "The goal is to make each of the fields optional. When e.g. your joints have no" "\n"
      "wrench associated with them, you can leave the wrench array empty." "\n"
      "" "\n"
      "All arrays in this message should have the same size, or be empty." "\n"
      "This is the only way to uniquely associate the joint name with the correct" "\n"
      "states.")
    struct MultiDOFJointState {
      std_msgs::msg::Header header;

      sequence<string> joint_names;

      sequence<geometry_msgs::msg::Transform> transforms;

      sequence<geometry_msgs::msg::Twist> twist;

      sequence<geometry_msgs::msg::Wrench> wrench;
    };
  };
};

================================================================================
IDL: geometry_msgs/msg/Transform

// generated from rosidl_adapter/resource/msg.idl.em
// with input from geometry_msgs/msg/Transform.msg
// generated code does not contain a copyright notice


module geometry_msgs {
  module msg {
    @verbatim (language="comment", text=
      "This represents the transform between two coordinate frames in free space.")
    struct Transform {
      geometry_msgs::msg::Vector3 translation;

      geometry_msgs::msg::Quaternion rotation;
    };
  };
};

================================================================================
IDL: geometry_msgs/msg/Quaternion

// generated from rosidl_adapter/resource/msg.idl.em
// with input from geometry_msgs/msg/Quaternion.msg
// generated code does not contain a copyright notice


module geometry_msgs {
  module msg {
    @verbatim (language="comment", text=
      "This represents an orientation in free space in quaternion form.")
    struct Quaternion {
      @default (value=0.0)
      double x;

      @default (value=0.0)
      double y;

      @default (value=0.0)
      double z;

      @default (value=1.0)
      double w;
    };
  };
};

================================================================================
IDL: geometry_msgs/msg/Vector3

// generated from rosidl_adapter/resource/msg.idl.em
// with input from geometry_msgs/msg/Vector3.msg
// generated code does not contain a copyright notice


module geometry_msgs {
  module msg {
    @verbatim (language="comment", text=
      "This represents a vector in free space.")
    struct Vector3 {
      @verbatim (language="comment", text=
        "This is semantically different than a point." "\n"
        "A vector is always anchored at the origin." "\n"
        "When a transform is applied to a vector, only the rotational component is applied.")
      double x;

      double y;

      double z;
    };
  };
};

================================================================================
IDL: geometry_msgs/msg/Twist

// generated from rosidl_adapter/resource/msg.idl.em
// with input from geometry_msgs/msg/Twist.msg
// generated code does not contain a copyright notice


module geometry_msgs {
  module msg {
    @verbatim (language="comment", text=
      "This expresses velocity in free space broken into its linear and angular parts.")
    struct Twist {
      geometry_msgs::msg::Vector3 linear;

      geometry_msgs::msg::Vector3 angular;
    };
  };
};

================================================================================
IDL: geometry_msgs/msg/Wrench

// generated from rosidl_adapter/resource/msg.idl.em
// with input from geometry_msgs/msg/Wrench.msg
// generated code does not contain a copyright notice


module geometry_msgs {
  module msg {
    @verbatim (language="comment", text=
      "This represents force in free space, separated into its linear and angular parts.")
    struct Wrench {
      geometry_msgs::msg::Vector3 force;

      geometry_msgs::msg::Vector3 torque;
    };
  };
};

================================================================================
IDL: std_msgs/msg/Header

// generated from rosidl_adapter/resource/msg.idl.em
// with input from std_msgs/msg/Header.msg
// generated code does not contain a copyright notice


module std_msgs {
  module msg {
    @verbatim (language="comment", text=
      "Standard metadata for higher-level stamped data types." "\n"
      "This is generally used to communicate timestamped data" "\n"
      "in a particular coordinate frame.")
    struct Header {
      @verbatim (language="comment", text=
        "Two-integer timestamp that is expressed as seconds and nanoseconds.")
      builtin_interfaces::msg::Time stamp;

      @verbatim (language="comment", text=
        "Transform frame with which this data is associated.")
      string frame_id;
    };
  };
};

================================================================================
IDL: builtin_interfaces/msg/Time

// generated from rosidl_adapter/resource/msg.idl.em
// with input from builtin_interfaces/msg/Time.msg
// generated code does not contain a copyright notice


module builtin_interfaces {
  module msg {
    @verbatim (language="comment", text=
      "This message communicates ROS Time defined here:" "\n"
      "https://design.ros2.org/articles/clock_and_time.html")
    struct Time {
      @verbatim (language="comment", text=
        "The seconds component, valid over all int32 values.")
      int32 sec;

      @verbatim (language="comment", text=
        "The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component." "\n"
        "e.g." "\n"
        "The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}" "\n"
        "The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}")
      uint32 nanosec;
    };
  };
};

)mcap_schema";

            /*!
             * @brief Default constructor.
             */
            eProsima_user_DllExport MultiDOFJointState();

            /*!
             * @brief Default destructor.
             */
            eProsima_user_DllExport ~MultiDOFJointState();

            /*!
             * @brief Copy constructor.
             * @param x Reference to the object sensor_msgs::msg::MultiDOFJointState that will be copied.
             */
            eProsima_user_DllExport MultiDOFJointState(
                    const MultiDOFJointState& x);

            /*!
             * @brief Move constructor.
             * @param x Reference to the object sensor_msgs::msg::MultiDOFJointState that will be copied.
             */
            eProsima_user_DllExport MultiDOFJointState(
                    MultiDOFJointState&& x) noexcept;

            /*!
             * @brief Copy assignment.
             * @param x Reference to the object sensor_msgs::msg::MultiDOFJointState that will be copied.
             */
            eProsima_user_DllExport MultiDOFJointState& operator =(
                    const MultiDOFJointState& x);

            /*!
             * @brief Move assignment.
             * @param x Reference to the object sensor_msgs::msg::MultiDOFJointState that will be copied.
             */
            eProsima_user_DllExport MultiDOFJointState& operator =(
                    MultiDOFJointState&& x) noexcept;

            /*!
             * @brief Comparison operator.
             * @param x sensor_msgs::msg::MultiDOFJointState object to compare.
             */
            eProsima_user_DllExport bool operator ==(
                    const MultiDOFJointState& x) const;

            /*!
             * @brief Comparison operator.
             * @param x sensor_msgs::msg::MultiDOFJointState object to compare.
             */
            eProsima_user_DllExport bool operator !=(
                    const MultiDOFJointState& x) const;

            /*!
             * @brief This function copies the value in member header
             * @param _header New value to be copied in member header
             */
            eProsima_user_DllExport void header(
                    const std_msgs::msg::Header& _header);

            /*!
             * @brief This function moves the value in member header
             * @param _header New value to be moved in member header
             */
            eProsima_user_DllExport void header(
                    std_msgs::msg::Header&& _header);

            /*!
             * @brief This function returns a constant reference to member header
             * @return Constant reference to member header
             */
            eProsima_user_DllExport const std_msgs::msg::Header& header() const;

            /*!
             * @brief This function returns a reference to member header
             * @return Reference to member header
             */
            eProsima_user_DllExport std_msgs::msg::Header& header();
            /*!
             * @brief This function copies the value in member joint_names
             * @param _joint_names New value to be copied in member joint_names
             */
            eProsima_user_DllExport void joint_names(
                    const std::vector<std::string>& _joint_names);

            /*!
             * @brief This function moves the value in member joint_names
             * @param _joint_names New value to be moved in member joint_names
             */
            eProsima_user_DllExport void joint_names(
                    std::vector<std::string>&& _joint_names);

            /*!
             * @brief This function returns a constant reference to member joint_names
             * @return Constant reference to member joint_names
             */
            eProsima_user_DllExport const std::vector<std::string>& joint_names() const;

            /*!
             * @brief This function returns a reference to member joint_names
             * @return Reference to member joint_names
             */
            eProsima_user_DllExport std::vector<std::string>& joint_names();
            /*!
             * @brief This function copies the value in member transforms
             * @param _transforms New value to be copied in member transforms
             */
            eProsima_user_DllExport void transforms(
                    const std::vector<geometry_msgs::msg::Transform>& _transforms);

            /*!
             * @brief This function moves the value in member transforms
             * @param _transforms New value to be moved in member transforms
             */
            eProsima_user_DllExport void transforms(
                    std::vector<geometry_msgs::msg::Transform>&& _transforms);

            /*!
             * @brief This function returns a constant reference to member transforms
             * @return Constant reference to member transforms
             */
            eProsima_user_DllExport const std::vector<geometry_msgs::msg::Transform>& transforms() const;

            /*!
             * @brief This function returns a reference to member transforms
             * @return Reference to member transforms
             */
            eProsima_user_DllExport std::vector<geometry_msgs::msg::Transform>& transforms();
            /*!
             * @brief This function copies the value in member twist
             * @param _twist New value to be copied in member twist
             */
            eProsima_user_DllExport void twist(
                    const std::vector<geometry_msgs::msg::Twist>& _twist);

            /*!
             * @brief This function moves the value in member twist
             * @param _twist New value to be moved in member twist
             */
            eProsima_user_DllExport void twist(
                    std::vector<geometry_msgs::msg::Twist>&& _twist);

            /*!
             * @brief This function returns a constant reference to member twist
             * @return Constant reference to member twist
             */
            eProsima_user_DllExport const std::vector<geometry_msgs::msg::Twist>& twist() const;

            /*!
             * @brief This function returns a reference to member twist
             * @return Reference to member twist
             */
            eProsima_user_DllExport std::vector<geometry_msgs::msg::Twist>& twist();
            /*!
             * @brief This function copies the value in member wrench
             * @param _wrench New value to be copied in member wrench
             */
            eProsima_user_DllExport void wrench(
                    const std::vector<geometry_msgs::msg::Wrench>& _wrench);

            /*!
             * @brief This function moves the value in member wrench
             * @param _wrench New value to be moved in member wrench
             */
            eProsima_user_DllExport void wrench(
                    std::vector<geometry_msgs::msg::Wrench>&& _wrench);

            /*!
             * @brief This function returns a constant reference to member wrench
             * @return Constant reference to member wrench
             */
            eProsima_user_DllExport const std::vector<geometry_msgs::msg::Wrench>& wrench() const;

            /*!
             * @brief This function returns a reference to member wrench
             * @return Reference to member wrench
             */
            eProsima_user_DllExport std::vector<geometry_msgs::msg::Wrench>& wrench();

            /*!
            * @brief This function returns the maximum serialized size of an object
            * depending on the buffer alignment.
            * @param current_alignment Buffer alignment.
            * @return Maximum serialized size.
            */
            eProsima_user_DllExport static size_t getMaxCdrSerializedSize(
                    size_t current_alignment = 0);

            /*!
             * @brief This function returns the serialized size of a data depending on the buffer alignment.
             * @param data Data which is calculated its serialized size.
             * @param current_alignment Buffer alignment.
             * @return Serialized size.
             */
            eProsima_user_DllExport static size_t getCdrSerializedSize(
                    const sensor_msgs::msg::MultiDOFJointState& data,
                    size_t current_alignment = 0);


            /*!
             * @brief This function serializes an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void serialize(
                    eprosima::fastcdr::Cdr& cdr) const;

            /*!
             * @brief This function deserializes an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void deserialize(
                    eprosima::fastcdr::Cdr& cdr);



            /*!
             * @brief This function returns the maximum serialized size of the Key of an object
             * depending on the buffer alignment.
             * @param current_alignment Buffer alignment.
             * @return Maximum serialized size.
             */
            eProsima_user_DllExport static size_t getKeyMaxCdrSerializedSize(
                    size_t current_alignment = 0);

            /*!
             * @brief This function tells you if the Key has been defined for this type
             */
            eProsima_user_DllExport static bool isKeyDefined();

            /*!
             * @brief This function serializes the key members of an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void serializeKey(
                    eprosima::fastcdr::Cdr& cdr) const;

        private:

            std_msgs::msg::Header m_header;
            std::vector<std::string> m_joint_names;
            std::vector<geometry_msgs::msg::Transform> m_transforms;
            std::vector<geometry_msgs::msg::Twist> m_twist;
            std::vector<geometry_msgs::msg::Wrench> m_wrench;

        };
    } // namespace msg
} // namespace sensor_msgs

#endif // _FAST_DDS_GENERATED_SENSOR_MSGS_MSG_MULTIDOFJOINTSTATE_H_