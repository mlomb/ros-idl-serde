// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file SetCameraInfo.h
 * This header file contains the declaration of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifndef _FAST_DDS_GENERATED_SENSOR_MSGS_SRV_SETCAMERAINFO_H_
#define _FAST_DDS_GENERATED_SENSOR_MSGS_SRV_SETCAMERAINFO_H_

#include "sensor_msgs/msg/CameraInfo.h"

#include <fastrtps/utils/fixed_size_string.hpp>

#include <stdint.h>
#include <array>
#include <string>
#include <vector>
#include <map>
#include <bitset>

#if defined(_WIN32)
#if defined(EPROSIMA_USER_DLL_EXPORT)
#define eProsima_user_DllExport __declspec( dllexport )
#else
#define eProsima_user_DllExport
#endif  // EPROSIMA_USER_DLL_EXPORT
#else
#define eProsima_user_DllExport
#endif  // _WIN32

#if defined(_WIN32)
#if defined(EPROSIMA_USER_DLL_EXPORT)
#if defined(SetCameraInfo_SOURCE)
#define SetCameraInfo_DllAPI __declspec( dllexport )
#else
#define SetCameraInfo_DllAPI __declspec( dllimport )
#endif // SetCameraInfo_SOURCE
#else
#define SetCameraInfo_DllAPI
#endif  // EPROSIMA_USER_DLL_EXPORT
#else
#define SetCameraInfo_DllAPI
#endif // _WIN32

namespace eprosima {
namespace fastcdr {
class Cdr;
} // namespace fastcdr
} // namespace eprosima


namespace sensor_msgs {
    namespace srv {
        /*!
         * @brief This class represents the structure SetCameraInfo_Request defined by the user in the IDL file.
         * @ingroup SETCAMERAINFO
         */
        class SetCameraInfo_Request
        {
        public:
static constexpr std::string_view PACKAGE_RESOURCE_NAME = "sensor_msgs/srv/SetCameraInfo";
static constexpr std::string_view MCAP_SCHEMA = R"mcap_schema(================================================================================
IDL: sensor_msgs/srv/SetCameraInfo

// generated from rosidl_adapter/resource/srv.idl.em
// with input from sensor_msgs/srv/SetCameraInfo.srv
// generated code does not contain a copyright notice


module sensor_msgs {
  module srv {
    @verbatim (language="comment", text=
      "This service requests that a camera stores the given CameraInfo as that" "\n"
      "camera's calibration information." "\n"
      "" "\n"
      "The width and height in the camera_info field should match what the" "\n"
      "camera is currently outputting on its camera_info topic, and the camera" "\n"
      "will assume that the region of the imager that is being referred to is" "\n"
      "the region that the camera is currently capturing.")
    struct SetCameraInfo_Request {
      @verbatim (language="comment", text=
        "The camera_info to store")
      sensor_msgs::msg::CameraInfo camera_info;
    };
    struct SetCameraInfo_Response {
      @verbatim (language="comment", text=
        "True if the call succeeded")
      boolean success;

      @verbatim (language="comment", text=
        "Used to give details about success")
      string status_message;
    };
  };
};

================================================================================
IDL: sensor_msgs/msg/CameraInfo

// generated from rosidl_adapter/resource/msg.idl.em
// with input from sensor_msgs/msg/CameraInfo.msg
// generated code does not contain a copyright notice


module sensor_msgs {
  module msg {
    typedef double double__9[9];
    typedef double double__12[12];
    @verbatim (language="comment", text=
      "This message defines meta information for a camera. It should be in a" "\n"
      "camera namespace on topic \"camera_info\" and accompanied by up to five" "\n"
      "image topics named:" "\n"
      "" "\n"
      "  image_raw - raw data from the camera driver, possibly Bayer encoded" "\n"
      "  image            - monochrome, distorted" "\n"
      "  image_color      - color, distorted" "\n"
      "  image_rect       - monochrome, rectified" "\n"
      "  image_rect_color - color, rectified" "\n"
      "" "\n"
      "The image_pipeline contains packages (image_proc, stereo_image_proc)" "\n"
      "for producing the four processed image topics from image_raw and" "\n"
      "camera_info. The meaning of the camera parameters are described in" "\n"
      "detail at http://www.ros.org/wiki/image_pipeline/CameraInfo." "\n"
      "" "\n"
      "The image_geometry package provides a user-friendly interface to" "\n"
      "common operations using this meta information. If you want to, e.g.," "\n"
      "project a 3d point into image coordinates, we strongly recommend" "\n"
      "using image_geometry." "\n"
      "" "\n"
      "If the camera is uncalibrated, the matrices D, K, R, P should be left" "\n"
      "zeroed out. In particular, clients may assume that K == 0.0" "\n"
      "indicates an uncalibrated camera.")
    struct CameraInfo {
      @verbatim (language="comment", text=
        "                    Image acquisition info                          #" "\n"
        "" "\n"
        "Time of image acquisition, camera coordinate frame ID" "\n"
        "Header timestamp should be acquisition time of image" "\n"
        "Header frame_id should be optical frame of camera" "\n"
        "origin of frame should be optical center of camera" "\n"
        "+x should point to the right in the image" "\n"
        "+y should point down in the image" "\n"
        "+z should point into the plane of the image")
      std_msgs::msg::Header header;

      @verbatim (language="comment", text=
        "                     Calibration Parameters                         #" "\n"
        "" "\n"
        "These are fixed during camera calibration. Their values will be the #" "\n"
        "same in all messages until the camera is recalibrated. Note that    #" "\n"
        "self-calibrating systems may \"recalibrate\" frequently.              #" "\n"
        "                                                                    #" "\n"
        "The internal parameters can be used to warp a raw (distorted) image #" "\n"
        "to:                                                                 #" "\n"
        "  1. An undistorted image (requires D and K)                        #" "\n"
        "  2. A rectified image (requires D, K, R)                           #" "\n"
        "The projection matrix P projects 3D points into the rectified image.#" "\n"
        "" "\n"
        "The image dimensions with which the camera was calibrated." "\n"
        "Normally this will be the full camera resolution in pixels.")
      uint32 height;

      uint32 width;

      @verbatim (language="comment", text=
        "The distortion model used. Supported models are listed in" "\n"
        "sensor_msgs/distortion_models.hpp. For most cameras, \"plumb_bob\" - a" "\n"
        "simple model of radial and tangential distortion - is sufficent.")
      string distortion_model;

      @verbatim (language="comment", text=
        "The distortion parameters, size depending on the distortion model." "\n"
        "For \"plumb_bob\", the 5 parameters are: (k1, k2, t1, t2, k3).")
      sequence<double> d;

      @verbatim (language="comment", text=
        "Intrinsic camera matrix for the raw (distorted) images." "\n"
        "    [fx  0 cx]" "\n"
        "K = [ 0 fy cy]" "\n"
        "    [ 0  0  1]" "\n"
        "Projects 3D points in the camera coordinate frame to 2D pixel" "\n"
        "coordinates using the focal lengths (fx, fy) and principal point" "\n"
        "(cx, cy)." "\n"
        "3x3 row-major matrix")
      double__9 k;

      @verbatim (language="comment", text=
        "Rectification matrix (stereo cameras only)" "\n"
        "A rotation matrix aligning the camera coordinate system to the ideal" "\n"
        "stereo image plane so that epipolar lines in both stereo images are" "\n"
        "parallel." "\n"
        "3x3 row-major matrix")
      double__9 r;

      @verbatim (language="comment", text=
        "Projection/camera matrix" "\n"
        "    [fx'  0  cx' Tx]" "\n"
        "P = [ 0  fy' cy' Ty]" "\n"
        "    [ 0   0   1   0]" "\n"
        "By convention, this matrix specifies the intrinsic (camera) matrix" "\n"
        " of the processed (rectified) image. That is, the left 3x3 portion" "\n"
        " is the normal camera intrinsic matrix for the rectified image." "\n"
        "It projects 3D points in the camera coordinate frame to 2D pixel" "\n"
        " coordinates using the focal lengths (fx', fy') and principal point" "\n"
        " (cx', cy') - these may differ from the values in K." "\n"
        "For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will" "\n"
        " also have R = the identity and P[1:3,1:3] = K." "\n"
        "For a stereo pair, the fourth column [Tx Ty 0]' is related to the" "\n"
        " position of the optical center of the second camera in the first" "\n"
        " camera's frame. We assume Tz = 0 so both cameras are in the same" "\n"
        " stereo image plane. The first camera always has Tx = Ty = 0. For" "\n"
        " the right (second) camera of a horizontal stereo pair, Ty = 0 and" "\n"
        " Tx = -fx' * B, where B is the baseline between the cameras." "\n"
        "Given a 3D point [X Y Z]', the projection (x, y) of the point onto" "\n"
        " the rectified image is given by:" "\n"
        " [u v w]' = P * [X Y Z 1]'" "\n"
        "        x = u / w" "\n"
        "        y = v / w" "\n"
        " This holds for both images of a stereo pair." "\n"
        "3x4 row-major matrix")
      double__12 p;

      @verbatim (language="comment", text=
        "                     Operational Parameters                         #" "\n"
        "" "\n"
        "These define the image region actually captured by the camera       #" "\n"
        "driver. Although they affect the geometry of the output image, they #" "\n"
        "may be changed freely without recalibrating the camera.             #" "\n"
        "" "\n"
        "Binning refers here to any camera setting which combines rectangular" "\n"
        " neighborhoods of pixels into larger \"super-pixels.\" It reduces the" "\n"
        " resolution of the output image to" "\n"
        " (width / binning_x) x (height / binning_y)." "\n"
        "The default values binning_x = binning_y = 0 is considered the same" "\n"
        " as binning_x = binning_y = 1 (no subsampling).")
      uint32 binning_x;

      uint32 binning_y;

      @verbatim (language="comment", text=
        "Region of interest (subwindow of full camera resolution), given in" "\n"
        " full resolution (unbinned) image coordinates. A particular ROI" "\n"
        " always denotes the same window of pixels on the camera sensor," "\n"
        " regardless of binning settings." "\n"
        "The default setting of roi (all values 0) is considered the same as" "\n"
        " full resolution (roi.width = width, roi.height = height).")
      sensor_msgs::msg::RegionOfInterest roi;
    };
  };
};

================================================================================
IDL: sensor_msgs/msg/RegionOfInterest

// generated from rosidl_adapter/resource/msg.idl.em
// with input from sensor_msgs/msg/RegionOfInterest.msg
// generated code does not contain a copyright notice


module sensor_msgs {
  module msg {
    @verbatim (language="comment", text=
      "This message is used to specify a region of interest within an image." "\n"
      "" "\n"
      "When used to specify the ROI setting of the camera when the image was" "\n"
      "taken, the height and width fields should either match the height and" "\n"
      "width fields for the associated image; or height = width = 0" "\n"
      "indicates that the full resolution image was captured.")
    struct RegionOfInterest {
      @verbatim (language="comment", text=
        "Leftmost pixel of the ROI" "\n"
        "(0 if the ROI includes the left edge of the image)")
      uint32 x_offset;

      @verbatim (language="comment", text=
        "Topmost pixel of the ROI" "\n"
        "(0 if the ROI includes the top edge of the image)")
      uint32 y_offset;

      @verbatim (language="comment", text=
        "Height of ROI")
      uint32 height;

      @verbatim (language="comment", text=
        "Width of ROI")
      uint32 width;

      @verbatim (language="comment", text=
        "True if a distinct rectified ROI should be calculated from the \"raw\"" "\n"
        "ROI in this message. Typically this should be False if the full image" "\n"
        "is captured (ROI not used), and True if a subwindow is captured (ROI" "\n"
        "used).")
      boolean do_rectify;
    };
  };
};

================================================================================
IDL: std_msgs/msg/Header

// generated from rosidl_adapter/resource/msg.idl.em
// with input from std_msgs/msg/Header.msg
// generated code does not contain a copyright notice


module std_msgs {
  module msg {
    @verbatim (language="comment", text=
      "Standard metadata for higher-level stamped data types." "\n"
      "This is generally used to communicate timestamped data" "\n"
      "in a particular coordinate frame.")
    struct Header {
      @verbatim (language="comment", text=
        "Two-integer timestamp that is expressed as seconds and nanoseconds.")
      builtin_interfaces::msg::Time stamp;

      @verbatim (language="comment", text=
        "Transform frame with which this data is associated.")
      string frame_id;
    };
  };
};

================================================================================
IDL: builtin_interfaces/msg/Time

// generated from rosidl_adapter/resource/msg.idl.em
// with input from builtin_interfaces/msg/Time.msg
// generated code does not contain a copyright notice


module builtin_interfaces {
  module msg {
    @verbatim (language="comment", text=
      "This message communicates ROS Time defined here:" "\n"
      "https://design.ros2.org/articles/clock_and_time.html")
    struct Time {
      @verbatim (language="comment", text=
        "The seconds component, valid over all int32 values.")
      int32 sec;

      @verbatim (language="comment", text=
        "The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component." "\n"
        "e.g." "\n"
        "The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}" "\n"
        "The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}")
      uint32 nanosec;
    };
  };
};

)mcap_schema";
static constexpr std::string_view MCAP_MSG_SCHEMA = R"mcap_msg_schema(<unavailable>)mcap_msg_schema";

            /*!
             * @brief Default constructor.
             */
            eProsima_user_DllExport SetCameraInfo_Request();

            /*!
             * @brief Default destructor.
             */
            eProsima_user_DllExport ~SetCameraInfo_Request();

            /*!
             * @brief Copy constructor.
             * @param x Reference to the object sensor_msgs::srv::SetCameraInfo_Request that will be copied.
             */
            eProsima_user_DllExport SetCameraInfo_Request(
                    const SetCameraInfo_Request& x);

            /*!
             * @brief Move constructor.
             * @param x Reference to the object sensor_msgs::srv::SetCameraInfo_Request that will be copied.
             */
            eProsima_user_DllExport SetCameraInfo_Request(
                    SetCameraInfo_Request&& x) noexcept;

            /*!
             * @brief Copy assignment.
             * @param x Reference to the object sensor_msgs::srv::SetCameraInfo_Request that will be copied.
             */
            eProsima_user_DllExport SetCameraInfo_Request& operator =(
                    const SetCameraInfo_Request& x);

            /*!
             * @brief Move assignment.
             * @param x Reference to the object sensor_msgs::srv::SetCameraInfo_Request that will be copied.
             */
            eProsima_user_DllExport SetCameraInfo_Request& operator =(
                    SetCameraInfo_Request&& x) noexcept;

            /*!
             * @brief Comparison operator.
             * @param x sensor_msgs::srv::SetCameraInfo_Request object to compare.
             */
            eProsima_user_DllExport bool operator ==(
                    const SetCameraInfo_Request& x) const;

            /*!
             * @brief Comparison operator.
             * @param x sensor_msgs::srv::SetCameraInfo_Request object to compare.
             */
            eProsima_user_DllExport bool operator !=(
                    const SetCameraInfo_Request& x) const;

            /*!
             * @brief This function copies the value in member camera_info
             * @param _camera_info New value to be copied in member camera_info
             */
            eProsima_user_DllExport void camera_info(
                    const sensor_msgs::msg::CameraInfo& _camera_info);

            /*!
             * @brief This function moves the value in member camera_info
             * @param _camera_info New value to be moved in member camera_info
             */
            eProsima_user_DllExport void camera_info(
                    sensor_msgs::msg::CameraInfo&& _camera_info);

            /*!
             * @brief This function returns a constant reference to member camera_info
             * @return Constant reference to member camera_info
             */
            eProsima_user_DllExport const sensor_msgs::msg::CameraInfo& camera_info() const;

            /*!
             * @brief This function returns a reference to member camera_info
             * @return Reference to member camera_info
             */
            eProsima_user_DllExport sensor_msgs::msg::CameraInfo& camera_info();

            /*!
            * @brief This function returns the maximum serialized size of an object
            * depending on the buffer alignment.
            * @param current_alignment Buffer alignment.
            * @return Maximum serialized size.
            */
            eProsima_user_DllExport static size_t getMaxCdrSerializedSize(
                    size_t current_alignment = 0);

            /*!
             * @brief This function returns the serialized size of a data depending on the buffer alignment.
             * @param data Data which is calculated its serialized size.
             * @param current_alignment Buffer alignment.
             * @return Serialized size.
             */
            eProsima_user_DllExport static size_t getCdrSerializedSize(
                    const sensor_msgs::srv::SetCameraInfo_Request& data,
                    size_t current_alignment = 0);


            /*!
             * @brief This function serializes an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void serialize(
                    eprosima::fastcdr::Cdr& cdr) const;

            /*!
             * @brief This function deserializes an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void deserialize(
                    eprosima::fastcdr::Cdr& cdr);



            /*!
             * @brief This function returns the maximum serialized size of the Key of an object
             * depending on the buffer alignment.
             * @param current_alignment Buffer alignment.
             * @return Maximum serialized size.
             */
            eProsima_user_DllExport static size_t getKeyMaxCdrSerializedSize(
                    size_t current_alignment = 0);

            /*!
             * @brief This function tells you if the Key has been defined for this type
             */
            eProsima_user_DllExport static bool isKeyDefined();

            /*!
             * @brief This function serializes the key members of an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void serializeKey(
                    eprosima::fastcdr::Cdr& cdr) const;

        private:

            sensor_msgs::msg::CameraInfo m_camera_info;

        };
        /*!
         * @brief This class represents the structure SetCameraInfo_Response defined by the user in the IDL file.
         * @ingroup SETCAMERAINFO
         */
        class SetCameraInfo_Response
        {
        public:
static constexpr std::string_view PACKAGE_RESOURCE_NAME = "sensor_msgs/srv/SetCameraInfo";
static constexpr std::string_view MCAP_SCHEMA = R"mcap_schema(================================================================================
IDL: sensor_msgs/srv/SetCameraInfo

// generated from rosidl_adapter/resource/srv.idl.em
// with input from sensor_msgs/srv/SetCameraInfo.srv
// generated code does not contain a copyright notice


module sensor_msgs {
  module srv {
    @verbatim (language="comment", text=
      "This service requests that a camera stores the given CameraInfo as that" "\n"
      "camera's calibration information." "\n"
      "" "\n"
      "The width and height in the camera_info field should match what the" "\n"
      "camera is currently outputting on its camera_info topic, and the camera" "\n"
      "will assume that the region of the imager that is being referred to is" "\n"
      "the region that the camera is currently capturing.")
    struct SetCameraInfo_Request {
      @verbatim (language="comment", text=
        "The camera_info to store")
      sensor_msgs::msg::CameraInfo camera_info;
    };
    struct SetCameraInfo_Response {
      @verbatim (language="comment", text=
        "True if the call succeeded")
      boolean success;

      @verbatim (language="comment", text=
        "Used to give details about success")
      string status_message;
    };
  };
};

================================================================================
IDL: sensor_msgs/msg/CameraInfo

// generated from rosidl_adapter/resource/msg.idl.em
// with input from sensor_msgs/msg/CameraInfo.msg
// generated code does not contain a copyright notice


module sensor_msgs {
  module msg {
    typedef double double__9[9];
    typedef double double__12[12];
    @verbatim (language="comment", text=
      "This message defines meta information for a camera. It should be in a" "\n"
      "camera namespace on topic \"camera_info\" and accompanied by up to five" "\n"
      "image topics named:" "\n"
      "" "\n"
      "  image_raw - raw data from the camera driver, possibly Bayer encoded" "\n"
      "  image            - monochrome, distorted" "\n"
      "  image_color      - color, distorted" "\n"
      "  image_rect       - monochrome, rectified" "\n"
      "  image_rect_color - color, rectified" "\n"
      "" "\n"
      "The image_pipeline contains packages (image_proc, stereo_image_proc)" "\n"
      "for producing the four processed image topics from image_raw and" "\n"
      "camera_info. The meaning of the camera parameters are described in" "\n"
      "detail at http://www.ros.org/wiki/image_pipeline/CameraInfo." "\n"
      "" "\n"
      "The image_geometry package provides a user-friendly interface to" "\n"
      "common operations using this meta information. If you want to, e.g.," "\n"
      "project a 3d point into image coordinates, we strongly recommend" "\n"
      "using image_geometry." "\n"
      "" "\n"
      "If the camera is uncalibrated, the matrices D, K, R, P should be left" "\n"
      "zeroed out. In particular, clients may assume that K == 0.0" "\n"
      "indicates an uncalibrated camera.")
    struct CameraInfo {
      @verbatim (language="comment", text=
        "                    Image acquisition info                          #" "\n"
        "" "\n"
        "Time of image acquisition, camera coordinate frame ID" "\n"
        "Header timestamp should be acquisition time of image" "\n"
        "Header frame_id should be optical frame of camera" "\n"
        "origin of frame should be optical center of camera" "\n"
        "+x should point to the right in the image" "\n"
        "+y should point down in the image" "\n"
        "+z should point into the plane of the image")
      std_msgs::msg::Header header;

      @verbatim (language="comment", text=
        "                     Calibration Parameters                         #" "\n"
        "" "\n"
        "These are fixed during camera calibration. Their values will be the #" "\n"
        "same in all messages until the camera is recalibrated. Note that    #" "\n"
        "self-calibrating systems may \"recalibrate\" frequently.              #" "\n"
        "                                                                    #" "\n"
        "The internal parameters can be used to warp a raw (distorted) image #" "\n"
        "to:                                                                 #" "\n"
        "  1. An undistorted image (requires D and K)                        #" "\n"
        "  2. A rectified image (requires D, K, R)                           #" "\n"
        "The projection matrix P projects 3D points into the rectified image.#" "\n"
        "" "\n"
        "The image dimensions with which the camera was calibrated." "\n"
        "Normally this will be the full camera resolution in pixels.")
      uint32 height;

      uint32 width;

      @verbatim (language="comment", text=
        "The distortion model used. Supported models are listed in" "\n"
        "sensor_msgs/distortion_models.hpp. For most cameras, \"plumb_bob\" - a" "\n"
        "simple model of radial and tangential distortion - is sufficent.")
      string distortion_model;

      @verbatim (language="comment", text=
        "The distortion parameters, size depending on the distortion model." "\n"
        "For \"plumb_bob\", the 5 parameters are: (k1, k2, t1, t2, k3).")
      sequence<double> d;

      @verbatim (language="comment", text=
        "Intrinsic camera matrix for the raw (distorted) images." "\n"
        "    [fx  0 cx]" "\n"
        "K = [ 0 fy cy]" "\n"
        "    [ 0  0  1]" "\n"
        "Projects 3D points in the camera coordinate frame to 2D pixel" "\n"
        "coordinates using the focal lengths (fx, fy) and principal point" "\n"
        "(cx, cy)." "\n"
        "3x3 row-major matrix")
      double__9 k;

      @verbatim (language="comment", text=
        "Rectification matrix (stereo cameras only)" "\n"
        "A rotation matrix aligning the camera coordinate system to the ideal" "\n"
        "stereo image plane so that epipolar lines in both stereo images are" "\n"
        "parallel." "\n"
        "3x3 row-major matrix")
      double__9 r;

      @verbatim (language="comment", text=
        "Projection/camera matrix" "\n"
        "    [fx'  0  cx' Tx]" "\n"
        "P = [ 0  fy' cy' Ty]" "\n"
        "    [ 0   0   1   0]" "\n"
        "By convention, this matrix specifies the intrinsic (camera) matrix" "\n"
        " of the processed (rectified) image. That is, the left 3x3 portion" "\n"
        " is the normal camera intrinsic matrix for the rectified image." "\n"
        "It projects 3D points in the camera coordinate frame to 2D pixel" "\n"
        " coordinates using the focal lengths (fx', fy') and principal point" "\n"
        " (cx', cy') - these may differ from the values in K." "\n"
        "For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will" "\n"
        " also have R = the identity and P[1:3,1:3] = K." "\n"
        "For a stereo pair, the fourth column [Tx Ty 0]' is related to the" "\n"
        " position of the optical center of the second camera in the first" "\n"
        " camera's frame. We assume Tz = 0 so both cameras are in the same" "\n"
        " stereo image plane. The first camera always has Tx = Ty = 0. For" "\n"
        " the right (second) camera of a horizontal stereo pair, Ty = 0 and" "\n"
        " Tx = -fx' * B, where B is the baseline between the cameras." "\n"
        "Given a 3D point [X Y Z]', the projection (x, y) of the point onto" "\n"
        " the rectified image is given by:" "\n"
        " [u v w]' = P * [X Y Z 1]'" "\n"
        "        x = u / w" "\n"
        "        y = v / w" "\n"
        " This holds for both images of a stereo pair." "\n"
        "3x4 row-major matrix")
      double__12 p;

      @verbatim (language="comment", text=
        "                     Operational Parameters                         #" "\n"
        "" "\n"
        "These define the image region actually captured by the camera       #" "\n"
        "driver. Although they affect the geometry of the output image, they #" "\n"
        "may be changed freely without recalibrating the camera.             #" "\n"
        "" "\n"
        "Binning refers here to any camera setting which combines rectangular" "\n"
        " neighborhoods of pixels into larger \"super-pixels.\" It reduces the" "\n"
        " resolution of the output image to" "\n"
        " (width / binning_x) x (height / binning_y)." "\n"
        "The default values binning_x = binning_y = 0 is considered the same" "\n"
        " as binning_x = binning_y = 1 (no subsampling).")
      uint32 binning_x;

      uint32 binning_y;

      @verbatim (language="comment", text=
        "Region of interest (subwindow of full camera resolution), given in" "\n"
        " full resolution (unbinned) image coordinates. A particular ROI" "\n"
        " always denotes the same window of pixels on the camera sensor," "\n"
        " regardless of binning settings." "\n"
        "The default setting of roi (all values 0) is considered the same as" "\n"
        " full resolution (roi.width = width, roi.height = height).")
      sensor_msgs::msg::RegionOfInterest roi;
    };
  };
};

================================================================================
IDL: sensor_msgs/msg/RegionOfInterest

// generated from rosidl_adapter/resource/msg.idl.em
// with input from sensor_msgs/msg/RegionOfInterest.msg
// generated code does not contain a copyright notice


module sensor_msgs {
  module msg {
    @verbatim (language="comment", text=
      "This message is used to specify a region of interest within an image." "\n"
      "" "\n"
      "When used to specify the ROI setting of the camera when the image was" "\n"
      "taken, the height and width fields should either match the height and" "\n"
      "width fields for the associated image; or height = width = 0" "\n"
      "indicates that the full resolution image was captured.")
    struct RegionOfInterest {
      @verbatim (language="comment", text=
        "Leftmost pixel of the ROI" "\n"
        "(0 if the ROI includes the left edge of the image)")
      uint32 x_offset;

      @verbatim (language="comment", text=
        "Topmost pixel of the ROI" "\n"
        "(0 if the ROI includes the top edge of the image)")
      uint32 y_offset;

      @verbatim (language="comment", text=
        "Height of ROI")
      uint32 height;

      @verbatim (language="comment", text=
        "Width of ROI")
      uint32 width;

      @verbatim (language="comment", text=
        "True if a distinct rectified ROI should be calculated from the \"raw\"" "\n"
        "ROI in this message. Typically this should be False if the full image" "\n"
        "is captured (ROI not used), and True if a subwindow is captured (ROI" "\n"
        "used).")
      boolean do_rectify;
    };
  };
};

================================================================================
IDL: std_msgs/msg/Header

// generated from rosidl_adapter/resource/msg.idl.em
// with input from std_msgs/msg/Header.msg
// generated code does not contain a copyright notice


module std_msgs {
  module msg {
    @verbatim (language="comment", text=
      "Standard metadata for higher-level stamped data types." "\n"
      "This is generally used to communicate timestamped data" "\n"
      "in a particular coordinate frame.")
    struct Header {
      @verbatim (language="comment", text=
        "Two-integer timestamp that is expressed as seconds and nanoseconds.")
      builtin_interfaces::msg::Time stamp;

      @verbatim (language="comment", text=
        "Transform frame with which this data is associated.")
      string frame_id;
    };
  };
};

================================================================================
IDL: builtin_interfaces/msg/Time

// generated from rosidl_adapter/resource/msg.idl.em
// with input from builtin_interfaces/msg/Time.msg
// generated code does not contain a copyright notice


module builtin_interfaces {
  module msg {
    @verbatim (language="comment", text=
      "This message communicates ROS Time defined here:" "\n"
      "https://design.ros2.org/articles/clock_and_time.html")
    struct Time {
      @verbatim (language="comment", text=
        "The seconds component, valid over all int32 values.")
      int32 sec;

      @verbatim (language="comment", text=
        "The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component." "\n"
        "e.g." "\n"
        "The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}" "\n"
        "The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}")
      uint32 nanosec;
    };
  };
};

)mcap_schema";
static constexpr std::string_view MCAP_MSG_SCHEMA = R"mcap_msg_schema(<unavailable>)mcap_msg_schema";

            /*!
             * @brief Default constructor.
             */
            eProsima_user_DllExport SetCameraInfo_Response();

            /*!
             * @brief Default destructor.
             */
            eProsima_user_DllExport ~SetCameraInfo_Response();

            /*!
             * @brief Copy constructor.
             * @param x Reference to the object sensor_msgs::srv::SetCameraInfo_Response that will be copied.
             */
            eProsima_user_DllExport SetCameraInfo_Response(
                    const SetCameraInfo_Response& x);

            /*!
             * @brief Move constructor.
             * @param x Reference to the object sensor_msgs::srv::SetCameraInfo_Response that will be copied.
             */
            eProsima_user_DllExport SetCameraInfo_Response(
                    SetCameraInfo_Response&& x) noexcept;

            /*!
             * @brief Copy assignment.
             * @param x Reference to the object sensor_msgs::srv::SetCameraInfo_Response that will be copied.
             */
            eProsima_user_DllExport SetCameraInfo_Response& operator =(
                    const SetCameraInfo_Response& x);

            /*!
             * @brief Move assignment.
             * @param x Reference to the object sensor_msgs::srv::SetCameraInfo_Response that will be copied.
             */
            eProsima_user_DllExport SetCameraInfo_Response& operator =(
                    SetCameraInfo_Response&& x) noexcept;

            /*!
             * @brief Comparison operator.
             * @param x sensor_msgs::srv::SetCameraInfo_Response object to compare.
             */
            eProsima_user_DllExport bool operator ==(
                    const SetCameraInfo_Response& x) const;

            /*!
             * @brief Comparison operator.
             * @param x sensor_msgs::srv::SetCameraInfo_Response object to compare.
             */
            eProsima_user_DllExport bool operator !=(
                    const SetCameraInfo_Response& x) const;

            /*!
             * @brief This function sets a value in member success
             * @param _success New value for member success
             */
            eProsima_user_DllExport void success(
                    bool _success);

            /*!
             * @brief This function returns the value of member success
             * @return Value of member success
             */
            eProsima_user_DllExport bool success() const;

            /*!
             * @brief This function returns a reference to member success
             * @return Reference to member success
             */
            eProsima_user_DllExport bool& success();

            /*!
             * @brief This function copies the value in member status_message
             * @param _status_message New value to be copied in member status_message
             */
            eProsima_user_DllExport void status_message(
                    const std::string& _status_message);

            /*!
             * @brief This function moves the value in member status_message
             * @param _status_message New value to be moved in member status_message
             */
            eProsima_user_DllExport void status_message(
                    std::string&& _status_message);

            /*!
             * @brief This function returns a constant reference to member status_message
             * @return Constant reference to member status_message
             */
            eProsima_user_DllExport const std::string& status_message() const;

            /*!
             * @brief This function returns a reference to member status_message
             * @return Reference to member status_message
             */
            eProsima_user_DllExport std::string& status_message();

            /*!
            * @brief This function returns the maximum serialized size of an object
            * depending on the buffer alignment.
            * @param current_alignment Buffer alignment.
            * @return Maximum serialized size.
            */
            eProsima_user_DllExport static size_t getMaxCdrSerializedSize(
                    size_t current_alignment = 0);

            /*!
             * @brief This function returns the serialized size of a data depending on the buffer alignment.
             * @param data Data which is calculated its serialized size.
             * @param current_alignment Buffer alignment.
             * @return Serialized size.
             */
            eProsima_user_DllExport static size_t getCdrSerializedSize(
                    const sensor_msgs::srv::SetCameraInfo_Response& data,
                    size_t current_alignment = 0);


            /*!
             * @brief This function serializes an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void serialize(
                    eprosima::fastcdr::Cdr& cdr) const;

            /*!
             * @brief This function deserializes an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void deserialize(
                    eprosima::fastcdr::Cdr& cdr);



            /*!
             * @brief This function returns the maximum serialized size of the Key of an object
             * depending on the buffer alignment.
             * @param current_alignment Buffer alignment.
             * @return Maximum serialized size.
             */
            eProsima_user_DllExport static size_t getKeyMaxCdrSerializedSize(
                    size_t current_alignment = 0);

            /*!
             * @brief This function tells you if the Key has been defined for this type
             */
            eProsima_user_DllExport static bool isKeyDefined();

            /*!
             * @brief This function serializes the key members of an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void serializeKey(
                    eprosima::fastcdr::Cdr& cdr) const;

        private:

            bool m_success;
            std::string m_status_message;

        };
    } // namespace srv
} // namespace sensor_msgs

#endif // _FAST_DDS_GENERATED_SENSOR_MSGS_SRV_SETCAMERAINFO_H_