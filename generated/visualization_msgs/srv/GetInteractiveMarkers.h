// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file GetInteractiveMarkers.h
 * This header file contains the declaration of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifndef _FAST_DDS_GENERATED_VISUALIZATION_MSGS_SRV_GETINTERACTIVEMARKERS_H_
#define _FAST_DDS_GENERATED_VISUALIZATION_MSGS_SRV_GETINTERACTIVEMARKERS_H_

#include "visualization_msgs/msg/InteractiveMarker.h"

#include <fastrtps/utils/fixed_size_string.hpp>

#include <stdint.h>
#include <array>
#include <string>
#include <vector>
#include <map>
#include <bitset>

#if defined(_WIN32)
#if defined(EPROSIMA_USER_DLL_EXPORT)
#define eProsima_user_DllExport __declspec( dllexport )
#else
#define eProsima_user_DllExport
#endif  // EPROSIMA_USER_DLL_EXPORT
#else
#define eProsima_user_DllExport
#endif  // _WIN32

#if defined(_WIN32)
#if defined(EPROSIMA_USER_DLL_EXPORT)
#if defined(GetInteractiveMarkers_SOURCE)
#define GetInteractiveMarkers_DllAPI __declspec( dllexport )
#else
#define GetInteractiveMarkers_DllAPI __declspec( dllimport )
#endif // GetInteractiveMarkers_SOURCE
#else
#define GetInteractiveMarkers_DllAPI
#endif  // EPROSIMA_USER_DLL_EXPORT
#else
#define GetInteractiveMarkers_DllAPI
#endif // _WIN32

namespace eprosima {
namespace fastcdr {
class Cdr;
} // namespace fastcdr
} // namespace eprosima


namespace visualization_msgs {
    namespace srv {
        /*!
         * @brief This class represents the structure GetInteractiveMarkers_Request defined by the user in the IDL file.
         * @ingroup GETINTERACTIVEMARKERS
         */
        class GetInteractiveMarkers_Request
        {
        public:
static constexpr std::string_view MCAP_SCHEMA = R"(================================================================================
IDL: visualization_msgs/srv/GetInteractiveMarkers

// generated from rosidl_adapter/resource/srv.idl.em
// with input from visualization_msgs/srv/GetInteractiveMarkers.srv
// generated code does not contain a copyright notice


module visualization_msgs {
  module srv {
    struct GetInteractiveMarkers_Request {
      uint8 structure_needs_at_least_one_member;
    };
    @verbatim (language="comment", text=
      "Sequence number." "\n"
      "Set to the sequence number of the latest update message" "\n"
      "at the time the server received the request." "\n"
      "Clients use this to detect if any updates were missed.")
    struct GetInteractiveMarkers_Response {
      uint64 sequence_number;

      @verbatim (language="comment", text=
        "All interactive markers provided by the server.")
      sequence<visualization_msgs::msg::InteractiveMarker> markers;
    };
  };
};

================================================================================
IDL: visualization_msgs/msg/InteractiveMarker

// generated from rosidl_adapter/resource/msg.idl.em
// with input from visualization_msgs/msg/InteractiveMarker.msg
// generated code does not contain a copyright notice


module visualization_msgs {
  module msg {
    @verbatim (language="comment", text=
      "Time/frame info." "\n"
      "If header.time is set to 0, the marker will be retransformed into" "\n"
      "its frame on each timestep. You will receive the pose feedback" "\n"
      "in the same frame." "\n"
      "Otherwise, you might receive feedback in a different frame." "\n"
      "For rviz, this will be the current 'fixed frame' set by the user.")
    struct InteractiveMarker {
      std_msgs::msg::Header header;

      @verbatim (language="comment", text=
        "Initial pose. Also, defines the pivot point for rotations.")
      geometry_msgs::msg::Pose pose;

      @verbatim (language="comment", text=
        "Identifying string. Must be globally unique in" "\n"
        "the topic that this message is sent through.")
      string name;

      @verbatim (language="comment", text=
        "Short description (< 40 characters).")
      string description;

      @verbatim (language="comment", text=
        "Scale to be used for default controls (default=1).")
      float scale;

      @verbatim (language="comment", text=
        "All menu and submenu entries associated with this marker.")
      sequence<visualization_msgs::msg::MenuEntry> menu_entries;

      @verbatim (language="comment", text=
        "List of controls displayed for this marker.")
      sequence<visualization_msgs::msg::InteractiveMarkerControl> controls;
    };
  };
};

================================================================================
IDL: geometry_msgs/msg/Pose

// generated from rosidl_adapter/resource/msg.idl.em
// with input from geometry_msgs/msg/Pose.msg
// generated code does not contain a copyright notice


module geometry_msgs {
  module msg {
    @verbatim (language="comment", text=
      "A representation of pose in free space, composed of position and orientation.")
    struct Pose {
      geometry_msgs::msg::Point position;

      geometry_msgs::msg::Quaternion orientation;
    };
  };
};

================================================================================
IDL: geometry_msgs/msg/Point

// generated from rosidl_adapter/resource/msg.idl.em
// with input from geometry_msgs/msg/Point.msg
// generated code does not contain a copyright notice


module geometry_msgs {
  module msg {
    @verbatim (language="comment", text=
      "This contains the position of a point in free space")
    struct Point {
      double x;

      double y;

      double z;
    };
  };
};

================================================================================
IDL: geometry_msgs/msg/Quaternion

// generated from rosidl_adapter/resource/msg.idl.em
// with input from geometry_msgs/msg/Quaternion.msg
// generated code does not contain a copyright notice


module geometry_msgs {
  module msg {
    @verbatim (language="comment", text=
      "This represents an orientation in free space in quaternion form.")
    struct Quaternion {
      @default (value=0.0)
      double x;

      @default (value=0.0)
      double y;

      @default (value=0.0)
      double z;

      @default (value=1.0)
      double w;
    };
  };
};

================================================================================
IDL: std_msgs/msg/Header

// generated from rosidl_adapter/resource/msg.idl.em
// with input from std_msgs/msg/Header.msg
// generated code does not contain a copyright notice


module std_msgs {
  module msg {
    @verbatim (language="comment", text=
      "Standard metadata for higher-level stamped data types." "\n"
      "This is generally used to communicate timestamped data" "\n"
      "in a particular coordinate frame.")
    struct Header {
      @verbatim (language="comment", text=
        "Two-integer timestamp that is expressed as seconds and nanoseconds.")
      builtin_interfaces::msg::Time stamp;

      @verbatim (language="comment", text=
        "Transform frame with which this data is associated.")
      string frame_id;
    };
  };
};

================================================================================
IDL: builtin_interfaces/msg/Time

// generated from rosidl_adapter/resource/msg.idl.em
// with input from builtin_interfaces/msg/Time.msg
// generated code does not contain a copyright notice


module builtin_interfaces {
  module msg {
    @verbatim (language="comment", text=
      "This message communicates ROS Time defined here:" "\n"
      "https://design.ros2.org/articles/clock_and_time.html")
    struct Time {
      @verbatim (language="comment", text=
        "The seconds component, valid over all int32 values.")
      int32 sec;

      @verbatim (language="comment", text=
        "The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component." "\n"
        "e.g." "\n"
        "The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}" "\n"
        "The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}")
      uint32 nanosec;
    };
  };
};

================================================================================
IDL: visualization_msgs/msg/InteractiveMarkerControl

// generated from rosidl_adapter/resource/msg.idl.em
// with input from visualization_msgs/msg/InteractiveMarkerControl.msg
// generated code does not contain a copyright notice


module visualization_msgs {
  module msg {
    module InteractiveMarkerControl_Constants {
      @verbatim (language="comment", text=
        "Orientation mode: controls how orientation changes." "\n"        "INHERIT: Follow orientation of interactive marker" "\n"        "FIXED: Keep orientation fixed at initial state" "\n"        "VIEW_FACING: Align y-z plane with screen (x: forward, y:left, z:up).")
      const uint8 INHERIT = 0;
      const uint8 FIXED = 1;
      const uint8 VIEW_FACING = 2;
      @verbatim (language="comment", text=
        "Interaction mode for this control" "\n"        "" "\n"        "NONE: This control is only meant for visualization; no context menu." "\n"        "MENU: Like NONE, but right-click menu is active." "\n"        "BUTTON: Element can be left-clicked." "\n"        "MOVE_AXIS: Translate along local x-axis." "\n"        "MOVE_PLANE: Translate in local y-z plane." "\n"        "ROTATE_AXIS: Rotate around local x-axis." "\n"        "MOVE_ROTATE: Combines MOVE_PLANE and ROTATE_AXIS.")
      const uint8 NONE = 0;
      const uint8 MENU = 1;
      const uint8 BUTTON = 2;
      const uint8 MOVE_AXIS = 3;
      const uint8 MOVE_PLANE = 4;
      const uint8 ROTATE_AXIS = 5;
      const uint8 MOVE_ROTATE = 6;
      @verbatim (language="comment", text=
        "\"3D\" interaction modes work with the mouse+SHIFT+CTRL or with 3D cursors." "\n"        "MOVE_3D: Translate freely in 3D space." "\n"        "ROTATE_3D: Rotate freely in 3D space about the origin of parent frame." "\n"        "MOVE_ROTATE_3D: Full 6-DOF freedom of translation and rotation about the cursor origin.")
      const uint8 MOVE_3D = 7;
      const uint8 ROTATE_3D = 8;
      const uint8 MOVE_ROTATE_3D = 9;
    };
    @verbatim (language="comment", text=
      "Represents a control that is to be displayed together with an interactive marker")
    struct InteractiveMarkerControl {
      @verbatim (language="comment", text=
        "Identifying string for this control." "\n"
        "You need to assign a unique value to this to receive feedback from the GUI" "\n"
        "on what actions the user performs on this control (e.g. a button click).")
      string name;

      @verbatim (language="comment", text=
        "Defines the local coordinate frame (relative to the pose of the parent" "\n"
        "interactive marker) in which is being rotated and translated." "\n"
        "Default: Identity")
      geometry_msgs::msg::Quaternion orientation;

      uint8 orientation_mode;

      uint8 interaction_mode;

      @verbatim (language="comment", text=
        "If true, the contained markers will also be visible" "\n"
        "when the gui is not in interactive mode.")
      boolean always_visible;

      @verbatim (language="comment", text=
        "Markers to be displayed as custom visual representation." "\n"
        "Leave this empty to use the default control handles." "\n"
        "" "\n"
        "Note:" "\n"
        "- The markers can be defined in an arbitrary coordinate frame," "\n"
        "  but will be transformed into the local frame of the interactive marker." "\n"
        "- If the header of a marker is empty, its pose will be interpreted as" "\n"
        "  relative to the pose of the parent interactive marker.")
      sequence<visualization_msgs::msg::Marker> markers;

      @verbatim (language="comment", text=
        "In VIEW_FACING mode, set this to true if you don't want the markers" "\n"
        "to be aligned with the camera view point. The markers will show up" "\n"
        "as in INHERIT mode.")
      boolean independent_marker_orientation;

      @verbatim (language="comment", text=
        "Short description (< 40 characters) of what this control does," "\n"
        "e.g. \"Move the robot\"." "\n"
        "Default: A generic description based on the interaction mode")
      string description;
    };
  };
};

================================================================================
IDL: visualization_msgs/msg/Marker

// generated from rosidl_adapter/resource/msg.idl.em
// with input from visualization_msgs/msg/Marker.msg
// generated code does not contain a copyright notice


module visualization_msgs {
  module msg {
    module Marker_Constants {
      const int32 ARROW = 0;
      const int32 CUBE = 1;
      const int32 SPHERE = 2;
      const int32 CYLINDER = 3;
      const int32 LINE_STRIP = 4;
      const int32 LINE_LIST = 5;
      const int32 CUBE_LIST = 6;
      const int32 SPHERE_LIST = 7;
      const int32 POINTS = 8;
      const int32 TEXT_VIEW_FACING = 9;
      const int32 MESH_RESOURCE = 10;
      const int32 TRIANGLE_LIST = 11;
      const int32 ADD = 0;
      const int32 MODIFY = 0;
      const int32 DELETE = 2;
      const int32 DELETEALL = 3;
    };
    @verbatim (language="comment", text=
      "See:" "\n"
      " - http://www.ros.org/wiki/rviz/DisplayTypes/Marker" "\n"
      " - http://www.ros.org/wiki/rviz/Tutorials/Markers%3A%20Basic%20Shapes" "\n"
      "" "\n"
      "for more information on using this message with rviz.")
    struct Marker {
      @verbatim (language="comment", text=
        "Header for timestamp and frame id.")
      std_msgs::msg::Header header;

      @verbatim (language="comment", text=
        "Namespace in which to place the object." "\n"
        "Used in conjunction with id to create a unique name for the object.")
      string ns;

      @verbatim (language="comment", text=
        "Object ID used in conjunction with the namespace for manipulating and deleting the object later.")
      int32 id;

      @verbatim (language="comment", text=
        "Type of object.")
      int32 type;

      @verbatim (language="comment", text=
        "Action to take; one of:" "\n"
        " - 0 add/modify an object" "\n"
        " - 1 (deprecated)" "\n"
        " - 2 deletes an object (with the given ns and id)" "\n"
        " - 3 deletes all objects (or those with the given ns if any)")
      int32 action;

      @verbatim (language="comment", text=
        "Pose of the object with respect the frame_id specified in the header.")
      geometry_msgs::msg::Pose pose;

      @verbatim (language="comment", text=
        "Scale of the object; 1,1,1 means default (usually 1 meter square).")
      geometry_msgs::msg::Vector3 scale;

      @verbatim (language="comment", text=
        "Color of the object; in the range:")
      @unit (value="0.0-1.0")
      std_msgs::msg::ColorRGBA color;

      @verbatim (language="comment", text=
        "How long the object should last before being automatically deleted." "\n"
        "0 indicates forever.")
      builtin_interfaces::msg::Duration lifetime;

      @verbatim (language="comment", text=
        "If this marker should be frame-locked, i.e. retransformed into its frame every timestep.")
      boolean frame_locked;

      @verbatim (language="comment", text=
        "Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, etc.)")
      sequence<geometry_msgs::msg::Point> points;

      @verbatim (language="comment", text=
        "Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, etc.)" "\n"
        "The number of colors provided must either be 0 or equal to the number of points provided." "\n"
        "NOTE: alpha is not yet used")
      sequence<std_msgs::msg::ColorRGBA> colors;

      @verbatim (language="comment", text=
        "Texture resource is a special URI that can either reference a texture file in" "\n"
        "a format acceptable to (resource retriever)" "\n"
        "or an embedded texture via a string matching the format:" "\n"
        "  \"embedded://texture_name\"")
      @unit (value="https://index.ros.org/p/resource_retriever/")
      string texture_resource;

      @verbatim (language="comment", text=
        "An image to be loaded into the rendering engine as the texture for this marker." "\n"
        "This will be used iff texture_resource is set to embedded.")
      sensor_msgs::msg::CompressedImage texture;

      @verbatim (language="comment", text=
        "Location of each vertex within the texture; in the range:")
      @unit (value="0.0-1.0")
      sequence<visualization_msgs::msg::UVCoordinate> uv_coordinates;

      @verbatim (language="comment", text=
        "Only used for text markers")
      string text;

      @verbatim (language="comment", text=
        "Only used for MESH_RESOURCE markers." "\n"
        "Similar to texture_resource, mesh_resource uses resource retriever to load a mesh." "\n"
        "Optionally, a mesh file can be sent in-message via the mesh_file field. If doing so," "\n"
        "use the following format for mesh_resource:" "\n"
        "  \"embedded://mesh_name\"")
      string mesh_resource;

      visualization_msgs::msg::MeshFile mesh_file;

      boolean mesh_use_embedded_materials;
    };
  };
};

================================================================================
IDL: builtin_interfaces/msg/Duration

// generated from rosidl_adapter/resource/msg.idl.em
// with input from builtin_interfaces/msg/Duration.msg
// generated code does not contain a copyright notice


module builtin_interfaces {
  module msg {
    @verbatim (language="comment", text=
      "Duration defines a period between two time points." "\n"
      "Messages of this datatype are of ROS Time following this design:" "\n"
      "https://design.ros2.org/articles/clock_and_time.html")
    struct Duration {
      @verbatim (language="comment", text=
        "The seconds component, valid over all int32 values.")
      int32 sec;

      @verbatim (language="comment", text=
        "The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component." "\n"
        "e.g." "\n"
        "The duration -1.7 seconds is represented as {sec: -2, nanosec: 3e8}" "\n"
        "The duration 1.7 seconds is represented as {sec: 1, nanosec: 7e8}")
      uint32 nanosec;
    };
  };
};

================================================================================
IDL: geometry_msgs/msg/Vector3

// generated from rosidl_adapter/resource/msg.idl.em
// with input from geometry_msgs/msg/Vector3.msg
// generated code does not contain a copyright notice


module geometry_msgs {
  module msg {
    @verbatim (language="comment", text=
      "This represents a vector in free space.")
    struct Vector3 {
      @verbatim (language="comment", text=
        "This is semantically different than a point." "\n"
        "A vector is always anchored at the origin." "\n"
        "When a transform is applied to a vector, only the rotational component is applied.")
      double x;

      double y;

      double z;
    };
  };
};

================================================================================
IDL: sensor_msgs/msg/CompressedImage

// generated from rosidl_adapter/resource/msg.idl.em
// with input from sensor_msgs/msg/CompressedImage.msg
// generated code does not contain a copyright notice


module sensor_msgs {
  module msg {
    @verbatim (language="comment", text=
      "This message contains a compressed image.")
    struct CompressedImage {
      @verbatim (language="comment", text=
        "Header timestamp should be acquisition time of image" "\n"
        "Header frame_id should be optical frame of camera" "\n"
        "origin of frame should be optical center of cameara" "\n"
        "+x should point to the right in the image" "\n"
        "+y should point down in the image" "\n"
        "+z should point into to plane of the image")
      std_msgs::msg::Header header;

      @verbatim (language="comment", text=
        "Specifies the format of the data" "\n"
        "  Acceptable values:" "\n"
        "    jpeg, png, tiff")
      string format;

      @verbatim (language="comment", text=
        "Compressed image buffer")
      sequence<uint8> data;
    };
  };
};

================================================================================
IDL: std_msgs/msg/ColorRGBA

// generated from rosidl_adapter/resource/msg.idl.em
// with input from std_msgs/msg/ColorRGBA.msg
// generated code does not contain a copyright notice


module std_msgs {
  module msg {
    struct ColorRGBA {
      float r;

      float g;

      float b;

      float a;
    };
  };
};

================================================================================
IDL: visualization_msgs/msg/MeshFile

// generated from rosidl_adapter/resource/msg.idl.em
// with input from visualization_msgs/msg/MeshFile.msg
// generated code does not contain a copyright notice


module visualization_msgs {
  module msg {
    @verbatim (language="comment", text=
      "Used to send raw mesh files.")
    struct MeshFile {
      @verbatim (language="comment", text=
        "The filename is used for both debug purposes and to provide a file extension" "\n"
        "for whatever parser is used.")
      string filename;

      @verbatim (language="comment", text=
        "This stores the raw text of the mesh file.")
      sequence<uint8> data;
    };
  };
};

================================================================================
IDL: visualization_msgs/msg/UVCoordinate

// generated from rosidl_adapter/resource/msg.idl.em
// with input from visualization_msgs/msg/UVCoordinate.msg
// generated code does not contain a copyright notice


module visualization_msgs {
  module msg {
    @verbatim (language="comment", text=
      "Location of the pixel as a ratio of the width of a 2D texture." "\n"
      "Values should be in range:.")
    struct UVCoordinate {
      float u;

      float v;
    };
  };
};

================================================================================
IDL: visualization_msgs/msg/MenuEntry

// generated from rosidl_adapter/resource/msg.idl.em
// with input from visualization_msgs/msg/MenuEntry.msg
// generated code does not contain a copyright notice


module visualization_msgs {
  module msg {
    module MenuEntry_Constants {
      @verbatim (language="comment", text=
        "Command_type stores the type of response desired when this menu" "\n"        "entry is clicked." "\n"        "FEEDBACK: send an InteractiveMarkerFeedback message with menu_entry_id set to this entry's id." "\n"        "ROSRUN: execute \"rosrun\" with arguments given in the command field (above)." "\n"        "ROSLAUNCH: execute \"roslaunch\" with arguments given in the command field (above).")
      const uint8 FEEDBACK = 0;
      const uint8 ROSRUN = 1;
      const uint8 ROSLAUNCH = 2;
    };
    @verbatim (language="comment", text=
      "MenuEntry message." "\n"
      "" "\n"
      "Each InteractiveMarker message has an array of MenuEntry messages." "\n"
      "A collection of MenuEntries together describe a" "\n"
      "menu/submenu/subsubmenu/etc tree, though they are stored in a flat" "\n"
      "array.  The tree structure is represented by giving each menu entry" "\n"
      "an ID number and a \"parent_id\" field.  Top-level entries are the" "\n"
      "ones with parent_id = 0.  Menu entries are ordered within their" "\n"
      "level the same way they are ordered in the containing array.  Parent" "\n"
      "entries must appear before their children." "\n"
      "" "\n"
      "Example:" "\n"
      "- id = 3" "\n"
      "  parent_id = 0" "\n"
      "  title = \"fun\"" "\n"
      "- id = 2" "\n"
      "  parent_id = 0" "\n"
      "  title = \"robot\"" "\n"
      "- id = 4" "\n"
      "  parent_id = 2" "\n"
      "  title = \"pr2\"" "\n"
      "- id = 5" "\n"
      "  parent_id = 2" "\n"
      "  title = \"turtle\"" "\n"
      "" "\n"
      "Gives a menu tree like this:" "\n"
      " - fun" "\n"
      " - robot" "\n"
      "   - pr2" "\n"
      "   - turtle")
    struct MenuEntry {
      @verbatim (language="comment", text=
        "ID is a number for each menu entry.  Must be unique within the" "\n"
        "control, and should never be 0.")
      uint32 id;

      @verbatim (language="comment", text=
        "ID of the parent of this menu entry, if it is a submenu.  If this" "\n"
        "menu entry is a top-level entry, set parent_id to 0.")
      uint32 parent_id;

      @verbatim (language="comment", text=
        "menu / entry title")
      string title;

      @verbatim (language="comment", text=
        "Arguments to command indicated by command_type (below)")
      string command;

      uint8 command_type;
    };
  };
};

)";

            /*!
             * @brief Default constructor.
             */
            eProsima_user_DllExport GetInteractiveMarkers_Request();

            /*!
             * @brief Default destructor.
             */
            eProsima_user_DllExport ~GetInteractiveMarkers_Request();

            /*!
             * @brief Copy constructor.
             * @param x Reference to the object visualization_msgs::srv::GetInteractiveMarkers_Request that will be copied.
             */
            eProsima_user_DllExport GetInteractiveMarkers_Request(
                    const GetInteractiveMarkers_Request& x);

            /*!
             * @brief Move constructor.
             * @param x Reference to the object visualization_msgs::srv::GetInteractiveMarkers_Request that will be copied.
             */
            eProsima_user_DllExport GetInteractiveMarkers_Request(
                    GetInteractiveMarkers_Request&& x) noexcept;

            /*!
             * @brief Copy assignment.
             * @param x Reference to the object visualization_msgs::srv::GetInteractiveMarkers_Request that will be copied.
             */
            eProsima_user_DllExport GetInteractiveMarkers_Request& operator =(
                    const GetInteractiveMarkers_Request& x);

            /*!
             * @brief Move assignment.
             * @param x Reference to the object visualization_msgs::srv::GetInteractiveMarkers_Request that will be copied.
             */
            eProsima_user_DllExport GetInteractiveMarkers_Request& operator =(
                    GetInteractiveMarkers_Request&& x) noexcept;

            /*!
             * @brief Comparison operator.
             * @param x visualization_msgs::srv::GetInteractiveMarkers_Request object to compare.
             */
            eProsima_user_DllExport bool operator ==(
                    const GetInteractiveMarkers_Request& x) const;

            /*!
             * @brief Comparison operator.
             * @param x visualization_msgs::srv::GetInteractiveMarkers_Request object to compare.
             */
            eProsima_user_DllExport bool operator !=(
                    const GetInteractiveMarkers_Request& x) const;

            /*!
             * @brief This function sets a value in member structure_needs_at_least_one_member
             * @param _structure_needs_at_least_one_member New value for member structure_needs_at_least_one_member
             */
            eProsima_user_DllExport void structure_needs_at_least_one_member(
                    uint8_t _structure_needs_at_least_one_member);

            /*!
             * @brief This function returns the value of member structure_needs_at_least_one_member
             * @return Value of member structure_needs_at_least_one_member
             */
            eProsima_user_DllExport uint8_t structure_needs_at_least_one_member() const;

            /*!
             * @brief This function returns a reference to member structure_needs_at_least_one_member
             * @return Reference to member structure_needs_at_least_one_member
             */
            eProsima_user_DllExport uint8_t& structure_needs_at_least_one_member();


            /*!
            * @brief This function returns the maximum serialized size of an object
            * depending on the buffer alignment.
            * @param current_alignment Buffer alignment.
            * @return Maximum serialized size.
            */
            eProsima_user_DllExport static size_t getMaxCdrSerializedSize(
                    size_t current_alignment = 0);

            /*!
             * @brief This function returns the serialized size of a data depending on the buffer alignment.
             * @param data Data which is calculated its serialized size.
             * @param current_alignment Buffer alignment.
             * @return Serialized size.
             */
            eProsima_user_DllExport static size_t getCdrSerializedSize(
                    const visualization_msgs::srv::GetInteractiveMarkers_Request& data,
                    size_t current_alignment = 0);


            /*!
             * @brief This function serializes an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void serialize(
                    eprosima::fastcdr::Cdr& cdr) const;

            /*!
             * @brief This function deserializes an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void deserialize(
                    eprosima::fastcdr::Cdr& cdr);



            /*!
             * @brief This function returns the maximum serialized size of the Key of an object
             * depending on the buffer alignment.
             * @param current_alignment Buffer alignment.
             * @return Maximum serialized size.
             */
            eProsima_user_DllExport static size_t getKeyMaxCdrSerializedSize(
                    size_t current_alignment = 0);

            /*!
             * @brief This function tells you if the Key has been defined for this type
             */
            eProsima_user_DllExport static bool isKeyDefined();

            /*!
             * @brief This function serializes the key members of an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void serializeKey(
                    eprosima::fastcdr::Cdr& cdr) const;

        private:

            uint8_t m_structure_needs_at_least_one_member;

        };
        /*!
         * @brief This class represents the structure GetInteractiveMarkers_Response defined by the user in the IDL file.
         * @ingroup GETINTERACTIVEMARKERS
         */
        class GetInteractiveMarkers_Response
        {
        public:
static constexpr std::string_view MCAP_SCHEMA = R"(================================================================================
IDL: visualization_msgs/srv/GetInteractiveMarkers

// generated from rosidl_adapter/resource/srv.idl.em
// with input from visualization_msgs/srv/GetInteractiveMarkers.srv
// generated code does not contain a copyright notice


module visualization_msgs {
  module srv {
    struct GetInteractiveMarkers_Request {
      uint8 structure_needs_at_least_one_member;
    };
    @verbatim (language="comment", text=
      "Sequence number." "\n"
      "Set to the sequence number of the latest update message" "\n"
      "at the time the server received the request." "\n"
      "Clients use this to detect if any updates were missed.")
    struct GetInteractiveMarkers_Response {
      uint64 sequence_number;

      @verbatim (language="comment", text=
        "All interactive markers provided by the server.")
      sequence<visualization_msgs::msg::InteractiveMarker> markers;
    };
  };
};

================================================================================
IDL: visualization_msgs/msg/InteractiveMarker

// generated from rosidl_adapter/resource/msg.idl.em
// with input from visualization_msgs/msg/InteractiveMarker.msg
// generated code does not contain a copyright notice


module visualization_msgs {
  module msg {
    @verbatim (language="comment", text=
      "Time/frame info." "\n"
      "If header.time is set to 0, the marker will be retransformed into" "\n"
      "its frame on each timestep. You will receive the pose feedback" "\n"
      "in the same frame." "\n"
      "Otherwise, you might receive feedback in a different frame." "\n"
      "For rviz, this will be the current 'fixed frame' set by the user.")
    struct InteractiveMarker {
      std_msgs::msg::Header header;

      @verbatim (language="comment", text=
        "Initial pose. Also, defines the pivot point for rotations.")
      geometry_msgs::msg::Pose pose;

      @verbatim (language="comment", text=
        "Identifying string. Must be globally unique in" "\n"
        "the topic that this message is sent through.")
      string name;

      @verbatim (language="comment", text=
        "Short description (< 40 characters).")
      string description;

      @verbatim (language="comment", text=
        "Scale to be used for default controls (default=1).")
      float scale;

      @verbatim (language="comment", text=
        "All menu and submenu entries associated with this marker.")
      sequence<visualization_msgs::msg::MenuEntry> menu_entries;

      @verbatim (language="comment", text=
        "List of controls displayed for this marker.")
      sequence<visualization_msgs::msg::InteractiveMarkerControl> controls;
    };
  };
};

================================================================================
IDL: geometry_msgs/msg/Pose

// generated from rosidl_adapter/resource/msg.idl.em
// with input from geometry_msgs/msg/Pose.msg
// generated code does not contain a copyright notice


module geometry_msgs {
  module msg {
    @verbatim (language="comment", text=
      "A representation of pose in free space, composed of position and orientation.")
    struct Pose {
      geometry_msgs::msg::Point position;

      geometry_msgs::msg::Quaternion orientation;
    };
  };
};

================================================================================
IDL: geometry_msgs/msg/Point

// generated from rosidl_adapter/resource/msg.idl.em
// with input from geometry_msgs/msg/Point.msg
// generated code does not contain a copyright notice


module geometry_msgs {
  module msg {
    @verbatim (language="comment", text=
      "This contains the position of a point in free space")
    struct Point {
      double x;

      double y;

      double z;
    };
  };
};

================================================================================
IDL: geometry_msgs/msg/Quaternion

// generated from rosidl_adapter/resource/msg.idl.em
// with input from geometry_msgs/msg/Quaternion.msg
// generated code does not contain a copyright notice


module geometry_msgs {
  module msg {
    @verbatim (language="comment", text=
      "This represents an orientation in free space in quaternion form.")
    struct Quaternion {
      @default (value=0.0)
      double x;

      @default (value=0.0)
      double y;

      @default (value=0.0)
      double z;

      @default (value=1.0)
      double w;
    };
  };
};

================================================================================
IDL: std_msgs/msg/Header

// generated from rosidl_adapter/resource/msg.idl.em
// with input from std_msgs/msg/Header.msg
// generated code does not contain a copyright notice


module std_msgs {
  module msg {
    @verbatim (language="comment", text=
      "Standard metadata for higher-level stamped data types." "\n"
      "This is generally used to communicate timestamped data" "\n"
      "in a particular coordinate frame.")
    struct Header {
      @verbatim (language="comment", text=
        "Two-integer timestamp that is expressed as seconds and nanoseconds.")
      builtin_interfaces::msg::Time stamp;

      @verbatim (language="comment", text=
        "Transform frame with which this data is associated.")
      string frame_id;
    };
  };
};

================================================================================
IDL: builtin_interfaces/msg/Time

// generated from rosidl_adapter/resource/msg.idl.em
// with input from builtin_interfaces/msg/Time.msg
// generated code does not contain a copyright notice


module builtin_interfaces {
  module msg {
    @verbatim (language="comment", text=
      "This message communicates ROS Time defined here:" "\n"
      "https://design.ros2.org/articles/clock_and_time.html")
    struct Time {
      @verbatim (language="comment", text=
        "The seconds component, valid over all int32 values.")
      int32 sec;

      @verbatim (language="comment", text=
        "The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component." "\n"
        "e.g." "\n"
        "The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}" "\n"
        "The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}")
      uint32 nanosec;
    };
  };
};

================================================================================
IDL: visualization_msgs/msg/InteractiveMarkerControl

// generated from rosidl_adapter/resource/msg.idl.em
// with input from visualization_msgs/msg/InteractiveMarkerControl.msg
// generated code does not contain a copyright notice


module visualization_msgs {
  module msg {
    module InteractiveMarkerControl_Constants {
      @verbatim (language="comment", text=
        "Orientation mode: controls how orientation changes." "\n"        "INHERIT: Follow orientation of interactive marker" "\n"        "FIXED: Keep orientation fixed at initial state" "\n"        "VIEW_FACING: Align y-z plane with screen (x: forward, y:left, z:up).")
      const uint8 INHERIT = 0;
      const uint8 FIXED = 1;
      const uint8 VIEW_FACING = 2;
      @verbatim (language="comment", text=
        "Interaction mode for this control" "\n"        "" "\n"        "NONE: This control is only meant for visualization; no context menu." "\n"        "MENU: Like NONE, but right-click menu is active." "\n"        "BUTTON: Element can be left-clicked." "\n"        "MOVE_AXIS: Translate along local x-axis." "\n"        "MOVE_PLANE: Translate in local y-z plane." "\n"        "ROTATE_AXIS: Rotate around local x-axis." "\n"        "MOVE_ROTATE: Combines MOVE_PLANE and ROTATE_AXIS.")
      const uint8 NONE = 0;
      const uint8 MENU = 1;
      const uint8 BUTTON = 2;
      const uint8 MOVE_AXIS = 3;
      const uint8 MOVE_PLANE = 4;
      const uint8 ROTATE_AXIS = 5;
      const uint8 MOVE_ROTATE = 6;
      @verbatim (language="comment", text=
        "\"3D\" interaction modes work with the mouse+SHIFT+CTRL or with 3D cursors." "\n"        "MOVE_3D: Translate freely in 3D space." "\n"        "ROTATE_3D: Rotate freely in 3D space about the origin of parent frame." "\n"        "MOVE_ROTATE_3D: Full 6-DOF freedom of translation and rotation about the cursor origin.")
      const uint8 MOVE_3D = 7;
      const uint8 ROTATE_3D = 8;
      const uint8 MOVE_ROTATE_3D = 9;
    };
    @verbatim (language="comment", text=
      "Represents a control that is to be displayed together with an interactive marker")
    struct InteractiveMarkerControl {
      @verbatim (language="comment", text=
        "Identifying string for this control." "\n"
        "You need to assign a unique value to this to receive feedback from the GUI" "\n"
        "on what actions the user performs on this control (e.g. a button click).")
      string name;

      @verbatim (language="comment", text=
        "Defines the local coordinate frame (relative to the pose of the parent" "\n"
        "interactive marker) in which is being rotated and translated." "\n"
        "Default: Identity")
      geometry_msgs::msg::Quaternion orientation;

      uint8 orientation_mode;

      uint8 interaction_mode;

      @verbatim (language="comment", text=
        "If true, the contained markers will also be visible" "\n"
        "when the gui is not in interactive mode.")
      boolean always_visible;

      @verbatim (language="comment", text=
        "Markers to be displayed as custom visual representation." "\n"
        "Leave this empty to use the default control handles." "\n"
        "" "\n"
        "Note:" "\n"
        "- The markers can be defined in an arbitrary coordinate frame," "\n"
        "  but will be transformed into the local frame of the interactive marker." "\n"
        "- If the header of a marker is empty, its pose will be interpreted as" "\n"
        "  relative to the pose of the parent interactive marker.")
      sequence<visualization_msgs::msg::Marker> markers;

      @verbatim (language="comment", text=
        "In VIEW_FACING mode, set this to true if you don't want the markers" "\n"
        "to be aligned with the camera view point. The markers will show up" "\n"
        "as in INHERIT mode.")
      boolean independent_marker_orientation;

      @verbatim (language="comment", text=
        "Short description (< 40 characters) of what this control does," "\n"
        "e.g. \"Move the robot\"." "\n"
        "Default: A generic description based on the interaction mode")
      string description;
    };
  };
};

================================================================================
IDL: visualization_msgs/msg/Marker

// generated from rosidl_adapter/resource/msg.idl.em
// with input from visualization_msgs/msg/Marker.msg
// generated code does not contain a copyright notice


module visualization_msgs {
  module msg {
    module Marker_Constants {
      const int32 ARROW = 0;
      const int32 CUBE = 1;
      const int32 SPHERE = 2;
      const int32 CYLINDER = 3;
      const int32 LINE_STRIP = 4;
      const int32 LINE_LIST = 5;
      const int32 CUBE_LIST = 6;
      const int32 SPHERE_LIST = 7;
      const int32 POINTS = 8;
      const int32 TEXT_VIEW_FACING = 9;
      const int32 MESH_RESOURCE = 10;
      const int32 TRIANGLE_LIST = 11;
      const int32 ADD = 0;
      const int32 MODIFY = 0;
      const int32 DELETE = 2;
      const int32 DELETEALL = 3;
    };
    @verbatim (language="comment", text=
      "See:" "\n"
      " - http://www.ros.org/wiki/rviz/DisplayTypes/Marker" "\n"
      " - http://www.ros.org/wiki/rviz/Tutorials/Markers%3A%20Basic%20Shapes" "\n"
      "" "\n"
      "for more information on using this message with rviz.")
    struct Marker {
      @verbatim (language="comment", text=
        "Header for timestamp and frame id.")
      std_msgs::msg::Header header;

      @verbatim (language="comment", text=
        "Namespace in which to place the object." "\n"
        "Used in conjunction with id to create a unique name for the object.")
      string ns;

      @verbatim (language="comment", text=
        "Object ID used in conjunction with the namespace for manipulating and deleting the object later.")
      int32 id;

      @verbatim (language="comment", text=
        "Type of object.")
      int32 type;

      @verbatim (language="comment", text=
        "Action to take; one of:" "\n"
        " - 0 add/modify an object" "\n"
        " - 1 (deprecated)" "\n"
        " - 2 deletes an object (with the given ns and id)" "\n"
        " - 3 deletes all objects (or those with the given ns if any)")
      int32 action;

      @verbatim (language="comment", text=
        "Pose of the object with respect the frame_id specified in the header.")
      geometry_msgs::msg::Pose pose;

      @verbatim (language="comment", text=
        "Scale of the object; 1,1,1 means default (usually 1 meter square).")
      geometry_msgs::msg::Vector3 scale;

      @verbatim (language="comment", text=
        "Color of the object; in the range:")
      @unit (value="0.0-1.0")
      std_msgs::msg::ColorRGBA color;

      @verbatim (language="comment", text=
        "How long the object should last before being automatically deleted." "\n"
        "0 indicates forever.")
      builtin_interfaces::msg::Duration lifetime;

      @verbatim (language="comment", text=
        "If this marker should be frame-locked, i.e. retransformed into its frame every timestep.")
      boolean frame_locked;

      @verbatim (language="comment", text=
        "Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, etc.)")
      sequence<geometry_msgs::msg::Point> points;

      @verbatim (language="comment", text=
        "Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, etc.)" "\n"
        "The number of colors provided must either be 0 or equal to the number of points provided." "\n"
        "NOTE: alpha is not yet used")
      sequence<std_msgs::msg::ColorRGBA> colors;

      @verbatim (language="comment", text=
        "Texture resource is a special URI that can either reference a texture file in" "\n"
        "a format acceptable to (resource retriever)" "\n"
        "or an embedded texture via a string matching the format:" "\n"
        "  \"embedded://texture_name\"")
      @unit (value="https://index.ros.org/p/resource_retriever/")
      string texture_resource;

      @verbatim (language="comment", text=
        "An image to be loaded into the rendering engine as the texture for this marker." "\n"
        "This will be used iff texture_resource is set to embedded.")
      sensor_msgs::msg::CompressedImage texture;

      @verbatim (language="comment", text=
        "Location of each vertex within the texture; in the range:")
      @unit (value="0.0-1.0")
      sequence<visualization_msgs::msg::UVCoordinate> uv_coordinates;

      @verbatim (language="comment", text=
        "Only used for text markers")
      string text;

      @verbatim (language="comment", text=
        "Only used for MESH_RESOURCE markers." "\n"
        "Similar to texture_resource, mesh_resource uses resource retriever to load a mesh." "\n"
        "Optionally, a mesh file can be sent in-message via the mesh_file field. If doing so," "\n"
        "use the following format for mesh_resource:" "\n"
        "  \"embedded://mesh_name\"")
      string mesh_resource;

      visualization_msgs::msg::MeshFile mesh_file;

      boolean mesh_use_embedded_materials;
    };
  };
};

================================================================================
IDL: builtin_interfaces/msg/Duration

// generated from rosidl_adapter/resource/msg.idl.em
// with input from builtin_interfaces/msg/Duration.msg
// generated code does not contain a copyright notice


module builtin_interfaces {
  module msg {
    @verbatim (language="comment", text=
      "Duration defines a period between two time points." "\n"
      "Messages of this datatype are of ROS Time following this design:" "\n"
      "https://design.ros2.org/articles/clock_and_time.html")
    struct Duration {
      @verbatim (language="comment", text=
        "The seconds component, valid over all int32 values.")
      int32 sec;

      @verbatim (language="comment", text=
        "The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component." "\n"
        "e.g." "\n"
        "The duration -1.7 seconds is represented as {sec: -2, nanosec: 3e8}" "\n"
        "The duration 1.7 seconds is represented as {sec: 1, nanosec: 7e8}")
      uint32 nanosec;
    };
  };
};

================================================================================
IDL: geometry_msgs/msg/Vector3

// generated from rosidl_adapter/resource/msg.idl.em
// with input from geometry_msgs/msg/Vector3.msg
// generated code does not contain a copyright notice


module geometry_msgs {
  module msg {
    @verbatim (language="comment", text=
      "This represents a vector in free space.")
    struct Vector3 {
      @verbatim (language="comment", text=
        "This is semantically different than a point." "\n"
        "A vector is always anchored at the origin." "\n"
        "When a transform is applied to a vector, only the rotational component is applied.")
      double x;

      double y;

      double z;
    };
  };
};

================================================================================
IDL: sensor_msgs/msg/CompressedImage

// generated from rosidl_adapter/resource/msg.idl.em
// with input from sensor_msgs/msg/CompressedImage.msg
// generated code does not contain a copyright notice


module sensor_msgs {
  module msg {
    @verbatim (language="comment", text=
      "This message contains a compressed image.")
    struct CompressedImage {
      @verbatim (language="comment", text=
        "Header timestamp should be acquisition time of image" "\n"
        "Header frame_id should be optical frame of camera" "\n"
        "origin of frame should be optical center of cameara" "\n"
        "+x should point to the right in the image" "\n"
        "+y should point down in the image" "\n"
        "+z should point into to plane of the image")
      std_msgs::msg::Header header;

      @verbatim (language="comment", text=
        "Specifies the format of the data" "\n"
        "  Acceptable values:" "\n"
        "    jpeg, png, tiff")
      string format;

      @verbatim (language="comment", text=
        "Compressed image buffer")
      sequence<uint8> data;
    };
  };
};

================================================================================
IDL: std_msgs/msg/ColorRGBA

// generated from rosidl_adapter/resource/msg.idl.em
// with input from std_msgs/msg/ColorRGBA.msg
// generated code does not contain a copyright notice


module std_msgs {
  module msg {
    struct ColorRGBA {
      float r;

      float g;

      float b;

      float a;
    };
  };
};

================================================================================
IDL: visualization_msgs/msg/MeshFile

// generated from rosidl_adapter/resource/msg.idl.em
// with input from visualization_msgs/msg/MeshFile.msg
// generated code does not contain a copyright notice


module visualization_msgs {
  module msg {
    @verbatim (language="comment", text=
      "Used to send raw mesh files.")
    struct MeshFile {
      @verbatim (language="comment", text=
        "The filename is used for both debug purposes and to provide a file extension" "\n"
        "for whatever parser is used.")
      string filename;

      @verbatim (language="comment", text=
        "This stores the raw text of the mesh file.")
      sequence<uint8> data;
    };
  };
};

================================================================================
IDL: visualization_msgs/msg/UVCoordinate

// generated from rosidl_adapter/resource/msg.idl.em
// with input from visualization_msgs/msg/UVCoordinate.msg
// generated code does not contain a copyright notice


module visualization_msgs {
  module msg {
    @verbatim (language="comment", text=
      "Location of the pixel as a ratio of the width of a 2D texture." "\n"
      "Values should be in range:.")
    struct UVCoordinate {
      float u;

      float v;
    };
  };
};

================================================================================
IDL: visualization_msgs/msg/MenuEntry

// generated from rosidl_adapter/resource/msg.idl.em
// with input from visualization_msgs/msg/MenuEntry.msg
// generated code does not contain a copyright notice


module visualization_msgs {
  module msg {
    module MenuEntry_Constants {
      @verbatim (language="comment", text=
        "Command_type stores the type of response desired when this menu" "\n"        "entry is clicked." "\n"        "FEEDBACK: send an InteractiveMarkerFeedback message with menu_entry_id set to this entry's id." "\n"        "ROSRUN: execute \"rosrun\" with arguments given in the command field (above)." "\n"        "ROSLAUNCH: execute \"roslaunch\" with arguments given in the command field (above).")
      const uint8 FEEDBACK = 0;
      const uint8 ROSRUN = 1;
      const uint8 ROSLAUNCH = 2;
    };
    @verbatim (language="comment", text=
      "MenuEntry message." "\n"
      "" "\n"
      "Each InteractiveMarker message has an array of MenuEntry messages." "\n"
      "A collection of MenuEntries together describe a" "\n"
      "menu/submenu/subsubmenu/etc tree, though they are stored in a flat" "\n"
      "array.  The tree structure is represented by giving each menu entry" "\n"
      "an ID number and a \"parent_id\" field.  Top-level entries are the" "\n"
      "ones with parent_id = 0.  Menu entries are ordered within their" "\n"
      "level the same way they are ordered in the containing array.  Parent" "\n"
      "entries must appear before their children." "\n"
      "" "\n"
      "Example:" "\n"
      "- id = 3" "\n"
      "  parent_id = 0" "\n"
      "  title = \"fun\"" "\n"
      "- id = 2" "\n"
      "  parent_id = 0" "\n"
      "  title = \"robot\"" "\n"
      "- id = 4" "\n"
      "  parent_id = 2" "\n"
      "  title = \"pr2\"" "\n"
      "- id = 5" "\n"
      "  parent_id = 2" "\n"
      "  title = \"turtle\"" "\n"
      "" "\n"
      "Gives a menu tree like this:" "\n"
      " - fun" "\n"
      " - robot" "\n"
      "   - pr2" "\n"
      "   - turtle")
    struct MenuEntry {
      @verbatim (language="comment", text=
        "ID is a number for each menu entry.  Must be unique within the" "\n"
        "control, and should never be 0.")
      uint32 id;

      @verbatim (language="comment", text=
        "ID of the parent of this menu entry, if it is a submenu.  If this" "\n"
        "menu entry is a top-level entry, set parent_id to 0.")
      uint32 parent_id;

      @verbatim (language="comment", text=
        "menu / entry title")
      string title;

      @verbatim (language="comment", text=
        "Arguments to command indicated by command_type (below)")
      string command;

      uint8 command_type;
    };
  };
};

)";

            /*!
             * @brief Default constructor.
             */
            eProsima_user_DllExport GetInteractiveMarkers_Response();

            /*!
             * @brief Default destructor.
             */
            eProsima_user_DllExport ~GetInteractiveMarkers_Response();

            /*!
             * @brief Copy constructor.
             * @param x Reference to the object visualization_msgs::srv::GetInteractiveMarkers_Response that will be copied.
             */
            eProsima_user_DllExport GetInteractiveMarkers_Response(
                    const GetInteractiveMarkers_Response& x);

            /*!
             * @brief Move constructor.
             * @param x Reference to the object visualization_msgs::srv::GetInteractiveMarkers_Response that will be copied.
             */
            eProsima_user_DllExport GetInteractiveMarkers_Response(
                    GetInteractiveMarkers_Response&& x) noexcept;

            /*!
             * @brief Copy assignment.
             * @param x Reference to the object visualization_msgs::srv::GetInteractiveMarkers_Response that will be copied.
             */
            eProsima_user_DllExport GetInteractiveMarkers_Response& operator =(
                    const GetInteractiveMarkers_Response& x);

            /*!
             * @brief Move assignment.
             * @param x Reference to the object visualization_msgs::srv::GetInteractiveMarkers_Response that will be copied.
             */
            eProsima_user_DllExport GetInteractiveMarkers_Response& operator =(
                    GetInteractiveMarkers_Response&& x) noexcept;

            /*!
             * @brief Comparison operator.
             * @param x visualization_msgs::srv::GetInteractiveMarkers_Response object to compare.
             */
            eProsima_user_DllExport bool operator ==(
                    const GetInteractiveMarkers_Response& x) const;

            /*!
             * @brief Comparison operator.
             * @param x visualization_msgs::srv::GetInteractiveMarkers_Response object to compare.
             */
            eProsima_user_DllExport bool operator !=(
                    const GetInteractiveMarkers_Response& x) const;

            /*!
             * @brief This function sets a value in member sequence_number
             * @param _sequence_number New value for member sequence_number
             */
            eProsima_user_DllExport void sequence_number(
                    uint64_t _sequence_number);

            /*!
             * @brief This function returns the value of member sequence_number
             * @return Value of member sequence_number
             */
            eProsima_user_DllExport uint64_t sequence_number() const;

            /*!
             * @brief This function returns a reference to member sequence_number
             * @return Reference to member sequence_number
             */
            eProsima_user_DllExport uint64_t& sequence_number();

            /*!
             * @brief This function copies the value in member markers
             * @param _markers New value to be copied in member markers
             */
            eProsima_user_DllExport void markers(
                    const std::vector<visualization_msgs::msg::InteractiveMarker>& _markers);

            /*!
             * @brief This function moves the value in member markers
             * @param _markers New value to be moved in member markers
             */
            eProsima_user_DllExport void markers(
                    std::vector<visualization_msgs::msg::InteractiveMarker>&& _markers);

            /*!
             * @brief This function returns a constant reference to member markers
             * @return Constant reference to member markers
             */
            eProsima_user_DllExport const std::vector<visualization_msgs::msg::InteractiveMarker>& markers() const;

            /*!
             * @brief This function returns a reference to member markers
             * @return Reference to member markers
             */
            eProsima_user_DllExport std::vector<visualization_msgs::msg::InteractiveMarker>& markers();

            /*!
            * @brief This function returns the maximum serialized size of an object
            * depending on the buffer alignment.
            * @param current_alignment Buffer alignment.
            * @return Maximum serialized size.
            */
            eProsima_user_DllExport static size_t getMaxCdrSerializedSize(
                    size_t current_alignment = 0);

            /*!
             * @brief This function returns the serialized size of a data depending on the buffer alignment.
             * @param data Data which is calculated its serialized size.
             * @param current_alignment Buffer alignment.
             * @return Serialized size.
             */
            eProsima_user_DllExport static size_t getCdrSerializedSize(
                    const visualization_msgs::srv::GetInteractiveMarkers_Response& data,
                    size_t current_alignment = 0);


            /*!
             * @brief This function serializes an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void serialize(
                    eprosima::fastcdr::Cdr& cdr) const;

            /*!
             * @brief This function deserializes an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void deserialize(
                    eprosima::fastcdr::Cdr& cdr);



            /*!
             * @brief This function returns the maximum serialized size of the Key of an object
             * depending on the buffer alignment.
             * @param current_alignment Buffer alignment.
             * @return Maximum serialized size.
             */
            eProsima_user_DllExport static size_t getKeyMaxCdrSerializedSize(
                    size_t current_alignment = 0);

            /*!
             * @brief This function tells you if the Key has been defined for this type
             */
            eProsima_user_DllExport static bool isKeyDefined();

            /*!
             * @brief This function serializes the key members of an object using CDR serialization.
             * @param cdr CDR serialization object.
             */
            eProsima_user_DllExport void serializeKey(
                    eprosima::fastcdr::Cdr& cdr) const;

        private:

            uint64_t m_sequence_number;
            std::vector<visualization_msgs::msg::InteractiveMarker> m_markers;

        };
    } // namespace srv
} // namespace visualization_msgs

#endif // _FAST_DDS_GENERATED_VISUALIZATION_MSGS_SRV_GETINTERACTIVEMARKERS_H_